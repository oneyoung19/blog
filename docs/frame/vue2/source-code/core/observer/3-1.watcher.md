---
title: watcher
---

`Watcher` 类是 `Vue` 响应式系统的核心。

```ts
class Watcher {
  constructor(
    vm: Component,              // Vue 实例
    expOrFn: string | Function, // 要监听的表达式或函数
    cb: Function,               // 回调函数
    options?: WatcherOptions    // 配置选项
  ) {
    // ... 初始化代码
  }

  // 重要的属性
  deep: boolean    // 是否深度监听
  lazy: boolean    // 是否懒执行（用于计算属性）
  dirty: boolean   // 是否需要重新计算（用于计算属性）
  sync: boolean    // 是否同步执行
  deps: Array<Dep> // 当前 watcher 依赖的所有 dep

  // 重要的方法
  get()          // 获取监听值
  addDep(dep: Dep) // 添加依赖
  cleanupDeps()  // 清理依赖
  update()       // 当依赖变化时触发更新
  run()          // 实际执行更新的方法
  evaluate()     // 评估值（用于计算属性）
  depend()       // 依赖收集
  teardown()     // 清理 watcher
}
```

## 1. constructor

```ts
// 1.支持直接传入getter
new Watcher(null, () => data.msg, (value) => {
  console.log(value)
})

// 2.或者传入字符串，利用parsePath方法解析
new Watcher(null, 'data.msg', (value) => {
  console.log(value)
})
```

当 `Watcher` 实例化时，`constructor` 方法主要做了两件事：

1. 触发 `getter` 方法。从而执行 `dep.depend` 方法，将当前 `Watcher` 实例添加到 `Dep` 的 `subs` 数组中。
2. 如果条件非 `lazy`，则触发 `this.get` 方法。

```ts
constructor(
  vm: Component | null,
  expOrFn: string | (() => any),
  cb: Function,
  options?: WatcherOptions | null,
  isRenderWatcher?: boolean
) {
  if ((this.vm = vm) && isRenderWatcher) {
    vm._watcher = this
  }
  // options
  if (options) {
    this.deep = !!options.deep
    this.user = !!options.user
    this.lazy = !!options.lazy
    this.sync = !!options.sync
    this.before = options.before
    if (__DEV__) {
      this.onTrack = options.onTrack
      this.onTrigger = options.onTrigger
    }
  } else {
    this.deep = this.user = this.lazy = this.sync = false
  }
  this.cb = cb
  this.id = ++uid // uid for batching
  this.active = true
  this.post = false
  this.dirty = this.lazy // for lazy watchers
  this.deps = []
  this.newDeps = []
  this.depIds = new Set()
  this.newDepIds = new Set()
  this.expression = __DEV__ ? expOrFn.toString() : ''
  // parse expression for getter
  if (isFunction(expOrFn)) {
    this.getter = expOrFn
  } else {
    this.getter = parsePath(expOrFn)
    if (!this.getter) {
      this.getter = noop
      __DEV__ &&
        warn(
          `Failed watching path: "${expOrFn}" ` +
            'Watcher only accepts simple dot-delimited paths. ' +
            'For full control, use a function instead.',
          vm
        )
    }
  }
  this.value = this.lazy ? undefined : this.get()
}
```