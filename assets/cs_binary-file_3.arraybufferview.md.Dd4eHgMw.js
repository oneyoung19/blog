import{_ as i,o as a,c as e,aP as n}from"./chunks/framework.D1yHhm2y.js";const c=JSON.parse('{"title":"ArrayBufferView","description":"","frontmatter":{"title":"ArrayBufferView"},"headers":[],"relativePath":"cs/binary-file/3.arraybufferview.md","filePath":"cs/binary-file/3.arraybufferview.md","lastUpdated":1735987451000}'),t={name:"cs/binary-file/3.arraybufferview.md"};function l(p,s,h,d,k,r){return a(),e("div",null,s[0]||(s[0]=[n(`<p>上一节阐述了如何声明 <code>ArrayBuffer</code>。而且其声明时的数值均为 <code>0</code>。</p><p>但在二进制的世界中，如何看待二进制的字节数，其结果是不同的。</p><p>譬如，长度为 <code>8</code> 的一串二进制 <code>01010101</code> 可以看做以下几种结果：</p><ol><li><code>0</code>、<code>1</code>、<code>0</code>、<code>1</code>、<code>0</code>、<code>1</code>、<code>0</code>、<code>1</code></li><li><code>01</code>、<code>01</code>、<code>01</code>、<code>01</code></li><li><code>0101</code>、<code>0101</code></li><li><code>01010101</code></li></ol><p>所以在这种情况下，我们能理解到的是：</p><p><strong>ArrayBuffer二进制集合本身数据是没有意义的，除非提供了规则解释器</strong>。</p><p>这里的规则解释器，也称作<strong>视图</strong>。</p><p>视图对象本身并不存储任何东西。它是一副<em>眼镜</em>，透过它来解释存储在 <code>ArrayBuffer</code> 中的字节。</p><p>视图有两种：</p><ol><li><code>TypedArray</code> 类型化数组。</li><li><code>DataView</code> 数据视图。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在计算机中，一些信息可以用 <code>1</code> 个字节表示，可以用 <code>2</code> 个字节表示，甚至可以用 <code>4</code> 个字节表示。</p><p>也就是说<strong>二进制数据本身的含义在不同的规则（视图）下，其表示的含义是不同的</strong>。</p><p>所以这就是为什么 <code>ArrayBuffer</code> 只有在特定视图才有意义。</p></div><h2 id="_1-typedarray" tabindex="-1">1.TypedArray <a class="header-anchor" href="#_1-typedarray" aria-label="Permalink to &quot;1.TypedArray&quot;">​</a></h2><p>在 <code>JavaScript</code> 中并不存在名为 <code>TypedArray</code> 的构造函数。</p><p>这里的 <code>TypedArray</code> 是一类构造函数的总称：</p><ol><li><code>Uint8Array</code>: <strong>8 位无符号整数</strong>。将每个字节视为 <code>0</code> 到 <code>255</code> 之间的单个数字（每个字节是 <code>8</code> 位，因此只能容纳那么多）。</li><li><code>Uint16Array</code>: <strong>16 位无符号整数</strong>。将每 <code>2</code> 个字节视为一个 <code>0</code> 到 <code>65535</code> 之间的整数。</li><li><code>Uint32Array</code>: <strong>32 位无符号整数</strong>将每 <code>4</code> 个字节视为一个 0 到 4294967295 之间的整数。</li><li><code>Uint8ClampedArray</code>: 用于 <code>8</code> 位整数，在赋值时便<strong>固定</strong>其值。</li><li><code>Int8Array</code>: <strong>8 位无符号整数</strong>。</li><li><code>Int16Array</code>: <strong>16 位无符号整数</strong>。</li><li><code>Int32Array</code>: <strong>32 位无符号整数</strong>。</li><li><code>Float32Array</code>: <strong>32 位有符号浮点数</strong>。</li><li><code>Float64Array</code>: <strong>64 位有符号浮点数</strong>。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这些类型化数组的行为类似于常规数组：<strong>具有索引，并且是可迭代的</strong>。</p></div><p>本文中的 <code>new TypedArray</code>，它表示 <code>new Uint8Array</code>、<code>new Int8Array</code> 及其他中之一。</p><h3 id="_1-1-语法" tabindex="-1">1-1.语法 <a class="header-anchor" href="#_1-1-语法" aria-label="Permalink to &quot;1-1.语法&quot;">​</a></h3><p><code>TypedArray</code> 的使用方法有以下五种：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1.以arrayBuffer为基础创建类型化数组 可以根据可选参数设置偏移量和指定长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arrayBuffer, [byteOffset], [length])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2.创建一个与目标数组相同长度的类型化数组，并复制其内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3.类型数组之间互相转化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typedArray)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4.创建指定长度的类型化数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(length)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5.创建长度为零的类型化数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>我们在此依次举例说明下前三种使用方式：</p><ol><li>以 <code>arrayBuffer</code> 为基础创建类型化数组，可以根据可选参数设置偏移量和指定长度。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrayBuffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint16Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arrayBuffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)</span></span></code></pre></div><p>这里我们声明了字节长度为 <code>8</code> 的 <code>arrayBuffer</code>，数值默认均为 <code>0</code>。</p><p>而后通过 <code>16</code> 位类型化数组视图（将两个字节视作一个数据）来描述它，最终视图数据长度为 <code>4</code>:</p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/main/img/e6c9d24ely1h3ce6eihn1j21sc0e4jtr.jpg" alt=""></p><ol start="2"><li>创建一个与目标数组相同长度的类型化数组，并复制其内容</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint16Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">72</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">101</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">108</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">108</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">111</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/main/img/e6c9d24ely1h3cefa8wrkj21ya0e6acj.jpg" alt=""></p><ol start="3"><li>类型数组之间互相转化</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr16 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint16Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">254</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr16)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr8 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr16)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr8)</span></span></code></pre></div><p>这里要说明的一个现象是，可能存在<strong>越界行为</strong>。</p><p>譬如，在 <code>Uint8Array</code> 下的数据范围 <code>[0, 256)</code>，所以 <code>256</code> 在 <code>Uint8Array</code> 下转化时，数据会<strong>截取丢失</strong>。</p><p>即 <code>100000000</code> 被截取为 <code>00000000</code>，所以转化结果是 <code>0</code>。</p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/main/img/e6c9d24ely1h3ceiiw25uj21vo0o6793.jpg" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>Uint8ClampedArray</code> 在这方面比较特殊，它的表现不太一样。</p><p>对于大于 <code>255</code> 的任何数字，它将保存为 <code>255</code>，对于任何负数，它将保存为 <code>0</code>。</p><p><strong>此行为对于图像处理很有用</strong>。</p></div><h3 id="_1-2-方法" tabindex="-1">1-2.方法 <a class="header-anchor" href="#_1-2-方法" aria-label="Permalink to &quot;1-2.方法&quot;">​</a></h3><p><code>TypedArray</code> 具有常规的 <code>Array</code> 方法。</p><p>可以遍历（<code>iterate</code>）、<code>map</code>、<code>slice</code>、<code>find</code> 和 <code>reduce</code>。</p><p>但有两个例外：</p><ul><li>没有 <code>splice</code> —— 我们无法“删除”一个值，因为类型化数组是缓冲区（<code>buffer</code>）上的视图，并且缓冲区（<code>buffer</code>）是固定的、连续的内存区域。我们所能做的就是分配一个零值。</li><li>无 <code>concat</code> 方法。</li></ul><p>另外，它还特有两种方法：</p><ul><li><code>arr.set(fromArr, [offset])</code>: 从 <code>offset</code>（默认为 <code>0</code>）开始，将 <code>fromArr</code> 中的所有元素复制到 <code>arr</code>。</li><li><code>arr.subarray([begin, end])</code>: 创建一个从 <code>begin</code> 到 <code>end</code>（不包括）相同类型的新视图。这类似于 <code>slice</code> 方法（同样也支持），但不复制任何内容，只是创建一个新视图，以对给定片段的数据进行操作。</li></ul><h2 id="_2-dataview" tabindex="-1">2.DataView <a class="header-anchor" href="#_2-dataview" aria-label="Permalink to &quot;2.DataView&quot;">​</a></h2><p>相比于类型化数组 <code>TypedArray</code>，<code>DataView</code> 的使用更加灵活。</p><p>对于类型化数组，构造器决定了其格式。整个数组应该是统一的。第 <code>i</code> 个数字是 <code>arr[i]</code>。</p><p>而通过 <code>DataView</code>，我们可以使用 <code>getUint8(i)</code> 或 <code>getUint16(i)</code> 之类的方法访问数据。</p><p>我们在调用方法时选择格式，而不是在构造的时候。</p><h3 id="_2-1-语法" tabindex="-1">2-1.语法 <a class="header-anchor" href="#_2-1-语法" aria-label="Permalink to &quot;2-1.语法&quot;">​</a></h3><p>其语法只有一种：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, [byteOffset], [byteLength])</span></span></code></pre></div><ul><li><code>buffer</code> —— 底层的 <code>ArrayBuffer</code>。与类型化数组不同，<code>DataView</code> 不会自行创建缓冲区（<code>buffer</code>）。我们需要事先准备好。</li><li><code>byteOffset</code> —— 视图的起始字节位置（默认为 <code>0</code>）。</li><li><code>byteLength</code> —— 视图的字节长度（默认至 <code>buffer</code> 的末尾）。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4 个字节的二进制数组，每个都是最大值 255</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]).buffer;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataView </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在偏移量为 0 处获取 8 位数字</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( dataView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUint8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 255</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( dataView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUint16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 65535（最大的 16 位无符号整数）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在偏移量为 0 处获取 32 位数字</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( dataView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUint32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4294967295（最大的 32 位无符号整数）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUint32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></span></code></pre></div><p>当混合格式的数据存储在同一缓冲区（<code>buffer</code>）中时，<code>DataView</code> 非常有用。</p><p>例如，当我们存储一个成对序列（<code>16</code> 位整数，<code>32</code> 位浮点数）时，用 <code>DataView</code> 可以轻松访问它们。</p>`,55)]))}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
