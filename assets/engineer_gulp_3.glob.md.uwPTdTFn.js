import{_ as o,c,o as d,b0 as t}from"./chunks/framework.CEggy_nf.js";const g=JSON.parse('{"title":"3.Glob","description":"","frontmatter":{"title":"3.Glob"},"headers":[],"relativePath":"engineer/gulp/3.glob.md","filePath":"engineer/gulp/3.glob.md","lastUpdated":1745140345000}'),s={name:"engineer/gulp/3.glob.md"};function p(r,e,i,l,n,a){return d(),c("div",null,e[0]||(e[0]=[t('<p><a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs/" target="_blank" rel="noreferrer">Gulp Glob</a></p><p><code>Glob</code> 是<strong>全局通配符</strong>（<code>Global Pattern</code>）的缩写。</p><p>它是一种通配符语言，用于匹配文件路径名。</p><p><code>Glob</code> 模式的语法类似于正则表达式，但是更加简单易懂，通常用于指定文件匹配模式。</p><p><strong>与正则表达式不同的是，<code>Glob</code> 模式只能用于匹配文件路径名，而不能用于匹配文件内容</strong>。</p><p>此处重点标记下一些常用的字符：</p><ol><li><code>/</code> 路径分隔符</li><li><code>\\\\</code> 转义字符</li><li><code>*</code> 匹配任何字符（除了路径分隔符 <code>/</code>），可以匹配 <code>0</code> 个或多个字符。</li><li><code>**</code> 匹配任何数量的目录层级（包括 <code>0</code> 个）。</li><li><code>!</code> 在整个模式的开头用于否定匹配，即排除匹配的文件。</li></ol><p>譬如：</p><p><code>*.js</code> 将匹配类似 <code>index.js</code> 的文件，但是不能匹配类似 <code>scripts/index.js</code> 或 <code>scripts/nested/index.js</code> 的文件。</p><p><code>&#39;scripts/**/*.js&#39;</code> 将匹配类似 <code>scripts/index.js</code>、<code>scripts/nested/index.js</code> 和 <code>scripts/nested/twice/index.js</code> 的文件。</p><p><code>[&#39;script/**/*.js&#39;, &#39;!scripts/vendor/&#39;]</code> 将匹配 <code>script</code> 文件夹下非 <code>vendor</code> 目录下的 <code>js</code> 文件。</p>',11)]))}const b=o(s,[["render",p]]);export{g as __pageData,b as default};
