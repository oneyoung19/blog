import{_ as i,c as e,o as a,b0 as n}from"./chunks/framework.DpiX_U7m.js";const g=JSON.parse('{"title":"3.动静分离","description":"","frontmatter":{"title":"3.动静分离"},"headers":[],"relativePath":"deploy/nginx/3.separation.md","filePath":"deploy/nginx/3.separation.md","lastUpdated":1748348682000}'),o={name:"deploy/nginx/3.separation.md"};function d(l,s,t,c,p,h){return a(),e("div",null,s[0]||(s[0]=[n(`<h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>该文章介绍前端静态资源部署的问题，暂不讨论<strong>强缓存</strong>与<strong>协商缓存</strong>等知识点。</p><h2 id="静态资源部署" tabindex="-1">静态资源部署 <a class="header-anchor" href="#静态资源部署" aria-label="Permalink to &quot;静态资源部署&quot;">​</a></h2><h3 id="上传前端项目" tabindex="-1">上传前端项目 <a class="header-anchor" href="#上传前端项目" aria-label="Permalink to &quot;上传前端项目&quot;">​</a></h3><ol><li>在前端服务器上，执行<code>cd /</code>进入到根目录。前端项目我通常会放在自己建立的<code>/data/web/</code>这个目录下。所以先利用<code>mkdir</code>命令创建<code>data</code>目录，然后<code>cd data</code>进入<code>data</code>目录后，再创建<code>web</code>目录并<code>cd web</code>。</li><li>我的项目名是<code>demo</code>。所以在<code>web</code>目录下新建一个<code>demo</code>目录。这个<code>demo</code>就可以上传压缩的前端项目<code>dist</code>包。<code>rz</code>选择<code>zip</code>包后，执行<code>unzip dist.zip</code>。</li><li>总结一下，我现在将项目部署到了前端服务器的<code>/data/web/demo/</code>目录下。</li></ol><h3 id="配置nginx" tabindex="-1">配置<code>nginx</code> <a class="header-anchor" href="#配置nginx" aria-label="Permalink to &quot;配置\`nginx\`&quot;">​</a></h3><ol><li><code>Nginx</code>分为<code>master</code>与<code>server</code>两种。通常在<code>master</code>中维护公共配置，一般是在<code>/etc/ngnix/nginx.conf</code>文件中配置，而在<code>server</code>中则针对不同的项目来进行不同的配置,一般是在<code>/etc/nginx/conf.d/</code>目录中新建<code>.conf</code>后缀文件来进行配置。</li><li>以上述<code>demo</code>为例，新建<code>demo.conf</code>，配置<code>location</code>块。</li></ol><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  listen </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">端口；</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  server_name ip或者域名；</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  location /demo/ {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root /data/web;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #不设置index的话 默认是index.html</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #index demo.html;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    access_log </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs/demo_access.log;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    error_log </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs/demo_error.log;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>上面配置的<code>Nginx</code>，当我们在浏览器中访问<code>网站/demo/test.html</code>时，就会映射到服务器的<code>/data/web/demo/test.html</code>。另外，<code>location</code>块这里有些比较重要的知识点。</li></ol><h3 id="location" tabindex="-1"><code>location</code> <a class="header-anchor" href="#location" aria-label="Permalink to &quot;\`location\`&quot;">​</a></h3><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  listen </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  server_name </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jsgoshu.cn;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> /blog/nginx/ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    root </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/data/web;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #alias /data/web/blog/nginx/;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    index </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    access_log </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs/blog_nginx_access.log;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    error_log </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs/blog_nginx_error.log;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li>路由匹配规则</li></ol><p>首先，一句话总结。匹配规则从高到低依次是<strong>精确匹配</strong>&gt;<strong><code>^~</code>的字符串匹配</strong>&gt;<strong>正则匹配</strong>&gt;<strong>字符串匹配</strong>。</p><p>匹配符号分为四类，分别是<code>=</code>、<code>~</code>、<code>~*</code>、<code>^~</code>。</p><p><code>=</code>表示<strong>精确匹配</strong>，优先级最高。</p><p><code>^~</code>表示<strong>字符串匹配</strong>，但优先级高于正则匹配</p><p><code>~</code>与<code>~*</code>表示<strong>正则匹配</strong>。</p><p>可能上面有点难以理解。<code>nginx</code>路由的一套完整匹配规则如下：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>①.&#39;=&#39;前缀的指令严格匹配这个查询。如果找到，停止搜索。</p><p>②.所有剩下的常规字符串，最长的匹配。如果这个匹配使用&#39;^~&#39;前缀，停止匹配。</p><p>③.正则表达式，按照在配置文件中定义的顺序。</p><p>④.如果第③条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。</p></div><ol start="2"><li><code>root</code>与<code>alias</code></li></ol><p><code>root</code>会将访问时匹配的路由与该<code>root</code>值拼接在一起，形成服务器上完整路径。可以对照<code>node</code>中的<code>path.resolve(__dirname, &#39;/blog/nginx/index.html&#39;)</code>来大致理解。</p><p>而<code>alias</code>意为<strong>别名</strong>。它是将访问时匹配的路由映射到服务器的实际路径。不会再拼接一次。</p><p>另外我个人在使用<code>alias</code>时，发现需要注意一些问题：</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>①<code>alias</code>只可以用来匹配目录，而不是静态资源。譬如访问路由是<code>/blog/nginx</code>，实际上会重定向到<code>/blog/nginx/</code>，这里的重定向会是301永久重定向。这种情况还好。但譬如访问<code>/test.jpg</code>，实际访问<code>/test.jpg/</code>。这就很严重了。</p><p>②301永久重定向会产生浏览器缓存，下次的请求会直接读取本地缓存，而不会发起网络请求。除非手动清除浏览器缓存并刷新。</p><p>③正是由于上面的原因，所以绝对不要用<code>alias</code>配置静态资源的映射访问。(<strong>其实现实中也不会用一个静态资源对应一个nginx匹配</strong>)。譬如：</p><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> /test.jpg </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    alias </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/blog/nginx/;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>当访问<code>域名/test.jpg</code>时，会产生301永久重定向到<code>域名/test.jpg/</code>。毫无疑问，页面上会出现<code>403</code>或者<code>404</code>。由于浏览器缓存，即使你换用<code>root</code>来重新配置<code>nginx</code>，<strong>只要原始访问路径不变</strong>，都不会起到效果。设想下，如果这种情况发生在生产环境😫。</p></div><p>总结：</p><pre><code>- \`nginx\`的匹配路由应该对应到目录，而不是某一静态资源。

- 即使想要直接匹配静态资源，也不要用\`alias\`。而是可以用\`root\`。
</code></pre><ol start="3"><li><code>try_files</code></li></ol><p><code>try_files</code>的使用，多见于部署<code>SPA</code>项目。</p><p>语法：<code>try_files $uri $uri/ index.html;</code></p><p><code>try_files</code>的作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示文件夹），如果前述的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。</p><p>假设访问路径是<code>jsgoshu.cn/blog/nginx</code>。而<code>location</code>配置简略如下：</p><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> /blog/ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  root </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/data/web;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try_files </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$uri $uri/ /blog/index.html;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  index </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>依次寻找<code>/data/web/blog/nginx</code> <code>data/web/blog/nginx/index.html</code>。都没有找到的话，就重定向到<code>/data/web/blog/index.html</code>。</p><ol start="4"><li><code>add_header</code></li></ol><p><code>add_header</code>可以用来设置响应头。常见的设置是这样：<code>add_header Cache-Control no-store;</code></p><ol start="5"><li><code>access_log</code>与<code>error_log</code></li></ol><p><code>access_log</code>与<code>error_log</code>分别代表的是访问日志与错误日志。这在开发中对于快速定位问题是非常有帮助的。所以推荐在配置<code>location</code>的时候也一定加上<code>log</code>。</p><p>另外要注意的是，在<code>conf.d</code>目录中自定义的的<code>conf</code>文件，都会以<code>include</code>引入到<code>nginx.conf</code>中。所以在设置<code>access_log</code>与<code>error_log</code>的<strong>相对路径</strong>时，实际上是要以<code>nginx.conf</code>的相对路径来设置。</p>`,38)]))}const k=i(o,[["render",d]]);export{g as __pageData,k as default};
