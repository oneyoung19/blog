import{_ as o,o as t,c as r,b0 as c}from"./chunks/framework.DDuwZS-e.js";const f=JSON.parse('{"title":"2-3-2.代理模式之defineProperty","description":"","frontmatter":{"title":"2-3-2.代理模式之defineProperty"},"headers":[],"relativePath":"cs/advance/design-pattern/2.structural-pattern/2-3-2.proxy-defineProperty.md","filePath":"cs/advance/design-pattern/2.structural-pattern/2-3-2.proxy-defineProperty.md","lastUpdated":1737702697000}'),d={name:"cs/advance/design-pattern/2.structural-pattern/2-3-2.proxy-defineProperty.md"};function p(a,e,n,i,l,s){return t(),r("div",null,e[0]||(e[0]=[c('<p><strong>代理模式之defineProperty</strong></p><p><code>Object.defineProperty</code> 不是严格意义上的代理模式，但它可以用来实现类似的功能，尤其是在属性访问控制和行为增强方面。</p><p>代理模式通常通过一个中间对象（代理）来控制对原对象的访问，而 <code>Object.defineProperty</code> 是通过直接定义或修改对象的属性行为来实现控制。</p><p><code>Object.defineProperty</code> 与 代理模式的区别:</p><ul><li>代理模式：使用代理模式时，我们通过一个代理对象来控制对目标对象的访问。代理模式可以拦截多种操作，比如属性读取、赋值、删除、函数调用等。<code>JavaScript</code> 中的 <code>Proxy</code> 对象是实现代理模式的工具。</li><li><code>Object.defineProperty</code>：它用于直接在对象上定义新属性或修改现有属性的行为，如是否可枚举、可写、可配置。它可以通过定义 <code>getter</code> 和 <code>setter</code> 来控制属性的读取和修改操作，但它仅限于特定属性的操作，不能拦截对象的其他行为（比如删除属性、函数调用等）。</li></ul><ol><li>数据描述符</li></ol><p><code>value</code> <code>writable</code> <code>enumerable</code> <code>configurable</code></p><ol start="2"><li>访问器描述符</li></ol><p><code>get</code> <code>set</code> <code>enumerable</code> <code>configurable</code></p><ol start="3"><li>设置描述符</li></ol><p><code>Object.defineProperty(obj, prop, descriptor)</code></p><ol start="4"><li>获取描述符</li></ol><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code></p>',13)]))}const u=o(d,[["render",p]]);export{f as __pageData,u as default};
