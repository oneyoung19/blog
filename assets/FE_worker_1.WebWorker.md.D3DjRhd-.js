import{_ as o,o as r,c as d,b0 as c}from"./chunks/framework.BnowZdcM.js";const _=JSON.parse('{"title":"1.Web Worker","description":"","frontmatter":{"title":"1.Web Worker"},"headers":[],"relativePath":"FE/worker/1.WebWorker.md","filePath":"FE/worker/1.WebWorker.md","lastUpdated":1770110642000}'),t={name:"FE/worker/1.WebWorker.md"};function a(p,e,n,s,i,W){return r(),d("div",null,[...e[0]||(e[0]=[c("<p>我们应该知道，<code>JavaScript</code> 是一门单线程的语言，因此 <strong><em><code>Main Threa</code>主线程</em></strong> 的大量计算等操作毫无疑问会造成页面卡顿、性能损耗。</p><p>而 <code>Worker</code> 则是浏览器提供的一条独立线程，方便开发者进行自定义操作。</p><p><strong>在 <code>Main Thread</code> 与 <code>Worker Thread</code> 之间，是利用了 <code>MessageEvent</code> 事件进行通信</strong>。</p><p><code>Web Worker</code> 是一类 <code>worker</code> 的统称。而且这一类 <code>worker</code> <strong>各有特点</strong>。</p><p>在现实业务中，<strong>根据 <code>API</code></strong>，我们可以将其大致细分为：</p><ul><li><p><code>Worker</code>：用于大型计算等消耗性能的操作；</p></li><li><p><code>SharedWorker</code>：用于跨 <code>Tab</code> 数据共享；</p></li><li><p><code>ServiceWorker</code>：用于 <code>JavaScript</code> 控制资源缓存，以实现渐进式 <code>web</code> 应用。</p></li></ul><p>在使用方式，<code>Worker</code> 和 <code>SharedWorker</code> 很类似，因此我们归为本章节统一论述。</p><p>而 <code>ServiceWorker</code> 与前两者大相径庭，涉及到 <code>PWA</code> 以及 <code>Cache</code> 策略等等，因此单独一个章节归纳。</p><p><strong>所有 <code>Worker</code> 的学习，都是对 <code>Main Thread</code> 和 <code>Worker Thread</code> 的 <code>API</code> 以及通信机制的归纳</strong>。</p>",9)])])}const l=o(t,[["render",a]]);export{_ as __pageData,l as default};
