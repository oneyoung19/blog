import{_ as e,c as t,o as r,b0 as l}from"./chunks/framework.CYy1HSjD.js";const h=JSON.parse('{"title":"TLS与SSL","description":"","frontmatter":{"title":"TLS与SSL"},"headers":[],"relativePath":"cs/https/tls&ssl.md","filePath":"cs/https/tls&ssl.md","lastUpdated":1750664209000}'),i={name:"cs/https/tls&ssl.md"};function n(s,o,c,a,d,p){return r(),t("div",null,o[0]||(o[0]=[l('<p><code>TLS</code>（<code>Transport Layer Security</code> 传输层安全协议）和 <code>SSL</code>（<code>Secure Sockets Layer</code> 安全套接层）都是用于加密和保护网络通信的协议。</p><p>它们的主要目的是确保在计算机之间传输的数据在传输过程中保持机密性和完整性，以防止未经授权的访问和数据篡改。</p><p><code>SSL</code> 是 <code>TLS</code> 的前身，最早由网景公司（<code>Netscape</code>）于 <code>1994</code> 年开发，用于安全地传输数据。</p><p><code>SSL</code>的不同版本（如 <code>SSL 2.0</code> 和 <code>SSL 3.0</code> ）存在一些安全漏洞，因此被 <code>TLS</code> 所取代。</p><p><code>TLS</code> 于 <code>1999</code> 年首次发布，是 <code>SSL 3.0</code> 的改进版本。</p><p><code>TLS</code> 的设计目标是修复 <code>SSL</code> 的安全漏洞并提供更强大的加密和认证方法。<code>TLS 1.0</code>也被称为 <code>SSL 3.1</code>。</p><h2 id="_1-对称加密" tabindex="-1">1.对称加密 <a class="header-anchor" href="#_1-对称加密" aria-label="Permalink to &quot;1.对称加密&quot;">​</a></h2><p><code>Symmetric encryption</code></p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/symmetric-encryption.webp" alt="" loading="lazy"></p><h2 id="_2-非对称加密" tabindex="-1">2.非对称加密 <a class="header-anchor" href="#_2-非对称加密" aria-label="Permalink to &quot;2.非对称加密&quot;">​</a></h2><p><code>Asymmetric encryption</code></p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/asymmetric-encryption.webp" alt="" loading="lazy"></p><h2 id="_3-https加密" tabindex="-1">3.HTTPS加密 <a class="header-anchor" href="#_3-https加密" aria-label="Permalink to &quot;3.HTTPS加密&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/https-encryption.webp" alt="" loading="lazy"></p><p>总的来说，如果我们将一次通信过程的双方，划分为 <code>Client</code> 客户端和 <code>Server</code> 服务端，那么在 <code>HTTPS</code> 通信流程中涉及到两点：</p><ol><li><strong>身份验证</strong>，即保证每次通信的双方都是可信的。</li><li><strong>信息安全</strong>，即保证每次通信的信息没有被篡改。</li></ol><p>下面，我们将通信过程，划分为<strong>请求阶段</strong>和<strong>响应阶段</strong>两个阶段，简单梳理下各个阶段是如何实现上述两点的。</p><h3 id="_3-1-请求阶段" tabindex="-1">3-1.请求阶段 <a class="header-anchor" href="#_3-1-请求阶段" aria-label="Permalink to &quot;3-1.请求阶段&quot;">​</a></h3><p>在请求阶段中，采用<strong>非对称加密</strong>：</p><ol><li>客户端生成一段随机字节，即<strong>预主密钥</strong>（<code>premaster secret</code>）;</li><li>客户端利用公钥将预主密钥进行信息加密；</li><li>客户端将加密的预主密钥发送到服务端；</li><li>服务端利用私钥将加密的预主密钥进行信息解密，得到预主密钥；</li><li>客户端和服务端会利用预主密钥，根据协商算法生成<strong>主密钥</strong>；</li><li>最终，客户端和服务端利用主密钥，生成<strong>会话密钥</strong>，在每一次通信中进行<strong>对称加密</strong>使用。</li></ol><p>该阶段的信息流是 <code>Client =&gt; Server</code>。那么 <code>Server</code> 要确定 <code>Client</code> 的身份和信息。</p><p>该阶段安全性校验的实现方式如下：</p><ol><li><strong>身份验证</strong>：最终通信会话，是依赖<strong>会话密钥</strong>的，也就是每一次会话都能确保是建立连接的双方。</li><li><strong>信息安全</strong>：非对称加密的公钥加密信息只能由对应的私钥来解密。<code>RSA</code> 算法很难破解。</li></ol><h3 id="_3-2-响应阶段" tabindex="-1">3-2.响应阶段 <a class="header-anchor" href="#_3-2-响应阶段" aria-label="Permalink to &quot;3-2.响应阶段&quot;">​</a></h3><p>在响应阶段中，采用<strong>数字签名</strong>：</p><ol><li>服务端先利用 <code>Hash</code> 算法对信息进行转码，生成不可逆的散列值；</li><li>然后利用私钥将散列值进行加密，加密结果即是<strong>数字签名</strong>；</li><li>服务端将数字签名和完整的响应信息，传递给客户端；</li><li>客户端接收到数字签名后，先利用公钥进行解密，得到散列值 <code>A</code>；</li><li>然后客户端将响应信息利用相同的 <code>Hash</code> 算法进行转码，得到散列值 <code>B</code>；</li><li>如果散列值 <code>A</code> 和 <code>B</code> 相同，则证明信息没有被篡改。反之，则已被篡改。</li></ol><p>该阶段的信息流是 <code>Server =&gt; Client</code>。那么 <code>Client</code> 要确定 <code>Server</code> 的身份和信息。</p><p>该阶段安全性校验的实现方式如下：</p><ol><li><strong>身份验证</strong>：私钥加密的信息，只能通过对应公钥来解密；</li><li><strong>信息安全</strong>：利用了<strong>数字签名</strong>的机制，会进行散列值比对，以确定信息是否被篡改。</li></ol><h3 id="_3-3-数字证书" tabindex="-1">3-3.数字证书 <a class="header-anchor" href="#_3-3-数字证书" aria-label="Permalink to &quot;3-3.数字证书&quot;">​</a></h3><p>上述两节梳理的两个阶段，都是在已经确立了公钥和私钥双方的情况下进行的。</p><p>但在实际业务中，要考虑怎么样交付公钥，也就是最初始步骤。</p><p><strong>如何保证私钥服务器上的公钥能够正常交付给客户端，而且客户端能够确信这个公钥是目标服务端产生的</strong>？</p><p>这部分需要依赖 <code>CA</code>（<code>Certificate Authority</code>）即<strong>证书颁发机构</strong>。</p><p>证书颁发机构是一种第三方实体或组织，负责颁发<strong>数字证书</strong>，以验证公共密钥的真实性和用户身份。</p><p>数字证书是一种用于加密通信和验证数据完整性的安全工具，通常用于 <code>HTTPS</code> 连接、电子邮件加密、数字签名等场景。</p><p>数字证书的原理是这样的：</p><ol><li>服务端需要向证书颁发机构申请数字证书；</li><li>证书颁发机构会生成密钥对，即公钥和私钥。这里的公钥一般被称作<strong>公共密钥</strong>；</li><li>证书颁发机构会根据私钥和证书相关信息，加密生成<strong>数字签名</strong>；</li><li>证书颁发机构会根据<strong>公共密钥</strong>、<strong>数字签名</strong>、<strong>持有人信息</strong>、<strong>证书有效期</strong>以及<strong>证书序列号</strong>生成数字证书；</li><li>客户端在访问服务端时，会获取数字证书；</li><li>如果证书已经过期的话，客户端便会提示不可信等等；</li><li>如果证书有效，那么就可以利用<strong>公共密钥</strong>对<strong>数字签名</strong>进行解密，然后比对证书信息；</li><li>结果一致的话，那就证明公钥是可信的。</li></ol><p>其实总的来说：</p><ol><li>初始的公钥交付以及验证功能，依赖于可信的第三方证书颁发机构。</li><li>证书验证功能，同样是数字签名的逻辑。</li></ol><h2 id="友情链接" tabindex="-1">友情链接 <a class="header-anchor" href="#友情链接" aria-label="Permalink to &quot;友情链接&quot;">​</a></h2><ul><li><a href="https://segmentfault.com/a/1190000021494676" target="_blank" rel="noreferrer">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noreferrer">数字签名是什么？ —— 阮一峰</a></li></ul>',42)]))}const S=e(i,[["render",n]]);export{h as __pageData,S as default};
