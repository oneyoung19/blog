import{_ as i,o as a,c as t,aP as e}from"./chunks/framework.D1yHhm2y.js";const r=JSON.parse('{"title":"OAuth2.0","description":"","frontmatter":{"title":"OAuth2.0"},"headers":[],"relativePath":"BE/authentication/oauth2/index.md","filePath":"BE/authentication/oauth2/index.md","lastUpdated":1736071640000}'),n={name:"BE/authentication/oauth2/index.md"};function p(l,s,h,o,k,d){return a(),t("div",null,s[0]||(s[0]=[e('<p><a href="https://datatracker.ietf.org/doc/html/rfc6749" target="_blank" rel="noreferrer">OAuth</a> 全称是 <code>Open Authorization</code>，它是一种授权机制。</p><p>数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。</p><p>系统从而产生一个短期的进入令牌（<code>token</code>），用来代替密码，供第三方应用使用。</p><p><code>OAuth2.0</code> 的令牌授权方式分为四种：</p><ol><li>授权码（<code>authorization-code</code>）</li><li>隐藏式（<code>implicit</code>）</li><li>密码式（<code>password</code>）</li><li>客户端凭证（<code>client-credentials</code>）</li></ol><h2 id="_1-授权码" tabindex="-1">1.授权码 <a class="header-anchor" href="#_1-授权码" aria-label="Permalink to &quot;1.授权码&quot;">​</a></h2><p>该模式<strong>适用于那些有后端的 <code>Web</code> 应用</strong>。</p><p>这种方式是最常用的流程，安全性也最高。</p><p>授权码（<code>authorization-code</code>）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p><p><strong>授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏</strong>。</p><h3 id="_1-1-获取授权码code" tabindex="-1">1-1.获取授权码code <a class="header-anchor" href="#_1-1-获取授权码code" aria-label="Permalink to &quot;1-1.获取授权码code&quot;">​</a></h3><p>譬如有客户端 <code>a.com</code> 和授权服务端 <code>b.com</code>，那么首先 <code>A</code> 网站可通过如下链接获取<strong>授权码</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`https://b.com/oauth/authorize</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ?response_type=code</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_id=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;redirect_uri=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIRECT_URI</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;scope=read`</span></span></code></pre></div><h3 id="_1-2-链接重定向" tabindex="-1">1-2.链接重定向 <a class="header-anchor" href="#_1-2-链接重定向" aria-label="Permalink to &quot;1-2.链接重定向&quot;">​</a></h3><p>在上述获取授权码成功之后，系统会重定向到新链接：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIRECT_URI</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}?code=AUTHORIZATION_CODE`</span></span></code></pre></div><h3 id="_1-3-获取令牌access-token" tabindex="-1">1-3.获取令牌access_token <a class="header-anchor" href="#_1-3-获取令牌access-token" aria-label="Permalink to &quot;1-3.获取令牌access_token&quot;">​</a></h3><p>在拿到授权码 <code>code</code> 之后，就可以在后端，向 <code>B</code> 网站请求令牌。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`https://b.com/oauth/token</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ?client_id=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_secret=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_SECRET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;grant_type=authorization_code</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;code=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AUTHORIZATION_CODE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span></code></pre></div><p>其中，<code>client_id</code> 参数和 <code>client_secret</code> 参数用来让 <code>B</code> 确认 <code>A</code> 的身份（<code>client_secret</code> 参数是保密的，因此只能在后端发请求）。</p><p>上述链接调用之后，大致会返回如下形式的 <code>JSON</code> 数据：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{    </span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;access_token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ACCESS_TOKEN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;token_type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bearer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;expires_in&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2592000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;refresh_token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;REFRESH_TOKEN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scope&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;read&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;uid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100101</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;info&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_2-隐藏式" tabindex="-1">2.隐藏式 <a class="header-anchor" href="#_2-隐藏式" aria-label="Permalink to &quot;2.隐藏式&quot;">​</a></h2><p>该模式<strong>适用于没有后端服务的纯前端应用</strong>。</p><p>隐藏式（<code>implicit</code>）允许直接向前端颁发令牌。</p><p>相对上节，该模式省略了<strong>授权码</strong>这个中间步骤。而是直接获取 <code>access_token</code>。</p><p><strong>为了防止令牌泄漏，<code>access_token</code> 通常定义到锚点而非 <code>queryString</code></strong>。</p><p>第一步，跳转到授权链接：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`https://b.com/oauth/authorize</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ?response_type=token</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_id=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;redirect_uri=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIRECT_URI</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;scope=read`</span></span></code></pre></div><p>授权成功后，会直接重定向到：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIRECT_URI</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}#token=ACCESS_TOKEN`</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li><p>令牌的位置是 <code>URL</code> 锚点（<code>fragment</code>），而不是查询字符串（<code>queryString</code>），这是因为 <code>OAuth2.0</code> 允许跳转网址是 <code>HTTP</code> 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p></li><li><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（<code>session</code>）有效，浏览器关掉，令牌就失效了。</p></li></ol></div><h2 id="_3-密码式" tabindex="-1">3.密码式 <a class="header-anchor" href="#_3-密码式" aria-label="Permalink to &quot;3.密码式&quot;">​</a></h2><p>该模式<strong>适用于其他授权模式不便使用，且用户高度信任的应用</strong>。</p><p>密码式允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌。</p><p><code>A</code> 网站直接请求如下链接，获取令牌：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`https://oauth.b.com/token</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ?grant_type=password</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;username=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">USERNAME</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;password=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PASSWORD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_id=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span></code></pre></div><p>该模式不存在 <code>REDIRECT_URI</code>，因此无需发生跳转。</p><p>而是会把令牌放到 <code>JSON</code> 数据里，作为 <code>HTTP</code> 响应。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>该模式需要用户给出自己的用户名/密码，风险很大，因此在实际业务中不推荐使用。</p></div><h2 id="_4-客户端凭证" tabindex="-1">4.客户端凭证 <a class="header-anchor" href="#_4-客户端凭证" aria-label="Permalink to &quot;4.客户端凭证&quot;">​</a></h2><p>该模式<strong>适用于没有前端的命令行应用，即在命令行下请求令牌</strong>。</p><p>第一步，在命令行访问链接：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`https://oauth.b.com/token</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ?grant_type=client_credentials</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_id=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &amp;client_secret=${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLIENT_SECRET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span></code></pre></div><p>验证通过之后，直接返回令牌。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p></div><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noreferrer">OAuth 2.0 的一个简单解释 by 阮一峰</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noreferrer">OAuth 2.0 的四种方式 by 阮一峰</a></li></ul>',48)]))}const F=i(n,[["render",p]]);export{r as __pageData,F as default};
