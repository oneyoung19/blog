import{_ as e,c as r,o as t,b0 as l}from"./chunks/framework.CEggy_nf.js";const u=JSON.parse('{"title":"设计模式","description":"","frontmatter":{"title":"设计模式"},"headers":[],"relativePath":"cs/advance/design-pattern/index.md","filePath":"cs/advance/design-pattern/index.md","lastUpdated":1745066937000}'),i={name:"cs/advance/design-pattern/index.md"};function o(n,a,c,s,h,d){return t(),r("div",null,a[0]||(a[0]=[l('<ul><li><a href="https://juejin.cn/post/6844904032826294286" target="_blank" rel="noreferrer">JavaScript设计模式es6（23种)</a></li><li><a href="https://juejin.cn/post/7052148234097000462" target="_blank" rel="noreferrer">10分钟掌握JavaScript设计模式</a></li><li><a href="https://github.com/oneyoung19/learn-cs" target="_blank" rel="noreferrer">learn-cs</a></li></ul><h2 id="设计模式原则" tabindex="-1">设计模式原则 <a class="header-anchor" href="#设计模式原则" aria-label="Permalink to &quot;设计模式原则&quot;">​</a></h2><ol><li><code>S</code> – <code>Single Responsibility Principle</code> 单一职责原则</li></ol><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul><ol start="2"><li><code>O</code> – <code>OpenClosed Principle</code> 开放/封闭原则</li></ol><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul><ol start="3"><li><code>L</code> – <code>Liskov Substitution Principle</code> 里氏替换原则</li></ol><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul><ol start="4"><li><code>I</code> – <code>Interface Segregation Principle</code> 接口隔离原则</li></ol><ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul><ol start="5"><li><code>D</code> – <code>Dependency Inversion Principle</code> 依赖倒转原则</li></ol><ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul><h2 id="模式分类" tabindex="-1">模式分类 <a class="header-anchor" href="#模式分类" aria-label="Permalink to &quot;模式分类&quot;">​</a></h2><h3 id="_1-创建型模式" tabindex="-1">1.创建型模式 <a class="header-anchor" href="#_1-创建型模式" aria-label="Permalink to &quot;1.创建型模式&quot;">​</a></h3><ol><li><a href="./1.creation-pattern/1-1.factory">工厂模式</a></li><li><a href="./1.creation-pattern/1-2.abstract-factory">抽象工厂模式</a></li><li><a href="./1.creation-pattern/1-3.singleton">单例模式</a></li><li><a href="./1.creation-pattern/1-4.constructor">构造器模式</a></li><li><a href="./1.creation-pattern/1-5.prototype">原型模式</a></li></ol><h3 id="_2-结构型模式" tabindex="-1">2.结构型模式 <a class="header-anchor" href="#_2-结构型模式" aria-label="Permalink to &quot;2.结构型模式&quot;">​</a></h3><ol><li><a href="./2.structural-pattern/2-1.adapter">适配器模式</a></li><li><a href="./2.structural-pattern/2-2-1.decorator-constructor">装饰器模式之构造函数</a>、<a href="./2.structural-pattern/2-2-2.decorator-class">装饰器模式之类</a></li><li>代理模式之<a href="./2.structural-pattern/2-3-1.proxy-delegate">对象委托代理</a>、<a href="./2.structural-pattern/2-3-3.proxy-es6">Proxy</a></li><li><a href="./2.structural-pattern/2-4.facade">外观模式</a></li><li><a href="./2.structural-pattern/2-5.bridge">桥接模式</a></li><li><a href="./2.structural-pattern/2-6.composite">组合模式</a></li><li><a href="./2.structural-pattern/2-7.flyweight">享元模式</a></li></ol><h3 id="_2-行为型模式" tabindex="-1">2.行为型模式 <a class="header-anchor" href="#_2-行为型模式" aria-label="Permalink to &quot;2.行为型模式&quot;">​</a></h3><ol><li><a href="./3.behavioral-pattern/3-1-1.observer">观察者模式</a>、<a href="./3.behavioral-pattern/3-1-2.observer-publish-subscribe">订阅-发布模式</a></li><li><a href="./3.behavioral-pattern/3-2-1.iterator">迭代器模式</a>、<a href="./3.behavioral-pattern/3-2-2.iterator-es6">ES6中的迭代器</a></li><li><a href="./3.behavioral-pattern/3-3.strategy">策略模式</a></li><li><a href="./3.behavioral-pattern/3-4.template-method">模板方法模式</a></li><li><a href="./3.behavioral-pattern/3-5.chain-of-responsibility">职责链模式</a></li><li><a href="./3.behavioral-pattern/3-6.command">命令模式</a></li><li><a href="./3.behavioral-pattern/3-7.memento">备忘录模式</a></li><li><a href="./3.behavioral-pattern/3-8.state">状态模式</a></li><li><a href="./3.behavioral-pattern/3-9.visitor">访问者模式</a></li><li><a href="./3.behavioral-pattern/3-10.mediator">中介者模式</a></li><li><a href="./3.behavioral-pattern/3-11.interpreter">解释器模式</a></li></ol>',19)]))}const f=e(i,[["render",o]]);export{u as __pageData,f as default};
