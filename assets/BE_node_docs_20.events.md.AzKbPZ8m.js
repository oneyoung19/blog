import{_ as s,c as i,o as t,b0 as n}from"./chunks/framework.CEggy_nf.js";const k=JSON.parse('{"title":"20.Events","description":"","frontmatter":{"title":"20.Events"},"headers":[],"relativePath":"BE/node/docs/20.events.md","filePath":"BE/node/docs/20.events.md","lastUpdated":1747214153000}'),a={name:"BE/node/docs/20.events.md"};function l(o,e,d,c,p,r){return t(),i("div",null,e[0]||(e[0]=[n(`<p>在 <code>Node.js</code> 中，<code>events</code> 模块是用于处理和触发事件的核心模块之一。</p><p>它提供了一个基本的事件驱动机制，使得不同的部分可以通过事件相互通信。</p><p><code>events</code> 模块的核心是 <code>EventEmitter</code> 类，几乎所有的 <code>Node.js</code> 核心模块（如 <code>HTTP</code>、<code>Stream</code>、<code>File System</code> 等）都基于 <code>EventEmitter</code> 实现了事件驱动的模式。</p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/20240808112402.png" alt="" loading="lazy"></p><p><code>EventEmitter</code> 类的常用方法</p><ul><li><code>on(eventName, listener)</code>: 为指定的事件注册一个监听器。可以注册多个监听器。</li><li><code>emit(eventName, [...args])</code>: 触发指定事件，并将可选的参数传递给监听器。</li><li><code>once(eventName, listener)</code>: 为指定事件注册一次性监听器，触发后自动移除。</li><li><code>off(eventName, listener) / removeListener(eventName, listener)</code>: 移除指定事件的监听器。</li><li><code>removeAllListeners([eventName])</code>: 移除所有或指定事件的所有监听器。</li><li><code>listeners(eventName)</code>: 返回指定事件的监听器数组。</li><li><code>eventNames()</code>: 返回当前注册的事件名数组。</li></ul><p>许多 <code>Node.js</code> 内置模块都继承自 <code>EventEmitter</code>，例如：</p><ul><li><code>http.Server</code>: 处理 <code>HTTP</code> 请求的服务器。</li><li><code>stream.Readable / stream.Writable</code>: 用于处理流的可读和可写数据。</li><li><code>net.Socket</code>: 处理网络连接。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> events</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;events&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(events)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const eventEmitter = new events.EventEmitter()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// eventEmitter.on(&#39;my_event&#39;, () =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   console.log(&#39;data received successfully.&#39;)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// eventEmitter.emit(&#39;my_event&#39;)</span></span></code></pre></div>`,9)]))}const v=s(a,[["render",l]]);export{k as __pageData,v as default};
