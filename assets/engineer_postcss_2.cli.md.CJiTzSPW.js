import{_ as e,o as t,c as a,aP as i}from"./chunks/framework.D1yHhm2y.js";const k=JSON.parse('{"title":"2.postcss-cli","description":"","frontmatter":{"title":"2.postcss-cli"},"headers":[],"relativePath":"engineer/postcss/2.cli.md","filePath":"engineer/postcss/2.cli.md","lastUpdated":1735988637000}'),o={name:"engineer/postcss/2.cli.md"};function c(p,s,n,l,d,r){return t(),a("div",null,s[0]||(s[0]=[i(`<p><a href="https://github.com/postcss/postcss-cli" target="_blank" rel="noreferrer">postcss-cli</a>是 <code>postcss</code> 官方提供的命令行工具。</p><p>但除此以外，现代工程化项目中，还可使用 <code>postcss-loader</code> 或 <code>gulp-postcss</code> 等。</p><p>它们的原理与作用基本类似。我们本章主要使用 <code>postcss-cli</code> 来一窥全貌。</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>安装 <code>postcss-cli</code> 的同时，要安装 <code>postcss</code>。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">yarn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> postcss-cli</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> postcss</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span></span></code></pre></div><p><code>postcss-cli</code> 是命令行工具，而 <code>postcss</code> 则是功能核心库。</p><h2 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h2><p>在 <code>package.json</code> 文件中添加 <code>scripts</code> 脚本：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;postcss -o styles/output.css -u autoprefixer --env production styles/entry.css&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上述 <code>build</code> 脚本会读取 <code>styles/entry.css</code> 内容，使用插件 <code>autoprefixer</code> 转换，然后生成 <code>styles/output.css</code> 文件，并且声明了 <code>env</code> 为 <code>production</code>（可在 <code>.postcssrc.js</code> 中的 <code>context</code> 访问）。</p><p>更加详细的指令介绍可以查看<a href="https://github.com/postcss/postcss-cli#usage" target="_blank" rel="noreferrer">usage</a>。</p>`,12)]))}const u=e(o,[["render",c]]);export{k as __pageData,u as default};
