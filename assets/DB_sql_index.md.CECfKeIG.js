import{_ as o,o as c,c as d,b0 as t}from"./chunks/framework.BnowZdcM.js";const u=JSON.parse('{"title":"前言","description":"","frontmatter":{"title":"前言"},"headers":[],"relativePath":"DB/sql/index.md","filePath":"DB/sql/index.md","lastUpdated":1770272701000}'),a={name:"DB/sql/index.md"};function i(r,e,n,s,l,p){return c(),d("div",null,[...e[0]||(e[0]=[t('<p><code>SQL</code> 全称为 <code>Structured Query Language</code>，即为<strong>结构化查询语言</strong>。</p><p>目前很多数据库（关系型数据库），都是建立在 <code>SQL</code> 上的。</p><p>如果把<strong>数据库</strong>比作<strong>盘子</strong>，那<strong>数据</strong>就是盘子里的<strong>菜</strong>，<code>SQL</code> 则是你的<strong>筷子</strong>。</p><p>有一些比较流行的数据库比如 <code>SQLite</code>、<code>MySQL</code>、<code>Postgres</code>、<code>Oracle</code> 和 <code>Microsoft SQL Server</code>.</p><p>所有这些数据库都支持标准的 <code>SQL</code>，换句话说，你学会了 <code>SQL</code> 就可以对这些数据库做数据操作了！</p><p>当然上面的每一种数据库都有自己的特性和适用范围（想象一下你家有不同尺寸的盘子).</p><p><strong>因此，在接触实际的数据库之前，我们需要先掌握基础 <code>SQL</code> 的使用方式。</strong></p><h2 id="关系型数据库" tabindex="-1">关系型数据库 <a class="header-anchor" href="#关系型数据库" aria-label="Permalink to &quot;关系型数据库&quot;">​</a></h2><p><code>RDBMS</code> 全称为 <code>Relational database management system</code>，关系型数据库，简单理解的话，就是<strong>表格结构的数据联系</strong>。</p><p>关系型数据库的数据是以表格的形式存储的，每一行代表一条数据，每一列代表一种数据类型。</p><p>关系型数据库遵循 <code>ACID</code> 原则，即 <code>Atomicity</code>（原子性）、<code>Consistency</code>（一致性）、<code>Isolation</code>（隔离性）和 <code>Durability</code>（持久性）。</p><h3 id="atomicity" tabindex="-1">Atomicity <a class="header-anchor" href="#atomicity" aria-label="Permalink to &quot;Atomicity&quot;">​</a></h3><p>原子性，即事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p>只要有一个事务操作失败，整个事务就会回滚，所有的操作都不会生效。</p><p>比如银行转账，从 <code>A</code> 账户转账 <code>100</code> 美元至 <code>B</code> 账户，分为两个步骤：</p><ol><li>从 <code>A</code> 账户扣除 <code>100</code> 美元</li><li>向 <code>B</code> 账户增加 <code>100</code> 美元</li></ol><p>这两步操作要么同时完成，要么同时不完成。</p><p>如果只完成了第一步，而第二步没有完成，那么 <code>A</code> 账户就少了 <code>100</code> 美元，而 <code>B</code> 账户却没有增加 <code>100</code> 美元，这就是一个不可分割的工作单位。</p><h3 id="consistency" tabindex="-1">Consistency <a class="header-anchor" href="#consistency" aria-label="Permalink to &quot;Consistency&quot;">​</a></h3><p>一致性，即事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p><p>例如现有完整性约束 <code>a+b=10</code>，如果一个事务改变了 <code>a</code>，那么必须得改变 <code>b</code>，使得事务结束后依然满足 <code>a+b=10</code>，否则事务失败。</p><h3 id="isolation" tabindex="-1">Isolation <a class="header-anchor" href="#isolation" aria-label="Permalink to &quot;Isolation&quot;">​</a></h3><p>独立性，即多个事务并发执行时，事务之间相互隔离，一个事务的执行不应该影响其他事务的执行。</p><p>比如银行转账，从 <code>A</code> 账户转账 <code>100</code> 美元至 <code>B</code> 账户。在这个交易还未完成的情况下，如果此时 <code>B</code> 查询自己的账户，是看不到新增加的<code>100</code> 美元的。</p><h3 id="durability" tabindex="-1">Durability <a class="header-anchor" href="#durability" aria-label="Permalink to &quot;Durability&quot;">​</a></h3><p>持久性，即一旦事务提交，它对数据库中数据的改变就应该是永久性的。</p>',26)])])}const m=o(a,[["render",i]]);export{u as __pageData,m as default};
