import{_ as a,c as s,o as n,b0 as c}from"./chunks/framework.CEggy_nf.js";const g=JSON.parse('{"title":"config files","description":"","frontmatter":{"title":"config files"},"headers":[],"relativePath":"engineer/babel/3.config-files.md","filePath":"engineer/babel/3.config-files.md","lastUpdated":1744257956000}'),o={name:"engineer/babel/3.config-files.md"};function d(l,e,p,i,b,r){return n(),s("div",null,e[0]||(e[0]=[c(`<p>在前一章，使用的 <code>yarn compiler:plugins</code> 以及 <code>yarn compiler:presets</code>，都是直接在命令行中配置了 <code>plugins</code> 及 <code>presets</code>。</p><p>这种方式不够优雅，而且不够友好。所以在理解 <code>plugins</code> 与 <code>presets</code> 之前，先来了解下 <code>babel</code> 提供的专门的配置文件来替代这种方式。</p><p>该配置文件有两种类型：</p><ol><li>项目范围的配置</li></ol><ul><li><code>babel.config.json</code> 文件。可使用扩展名有 <code>.json</code>、<code>.js</code>、<code>.cjs</code>、<code>.mjs</code>。</li></ul><ol start="2"><li>相对文件配置</li></ol><ul><li><code>.babelrc.json</code> 文件。可使用扩展名有 <code>.json</code>、<code>.js</code>、<code>.cjs</code>、<code>.mjs</code>。或者直接命名为 <code>.babelrc</code>。</li><li><code>package.json</code> 文件。 其中有 <code>key</code> 为 <code>babel</code> 的设置。</li></ul><p>在项目根目录下设置这两种类型的文件。<code>babel</code> 在执行的时候会自动寻找。</p><h2 id="_1-项目范围的配置" tabindex="-1">1.项目范围的配置 <a class="header-anchor" href="#_1-项目范围的配置" aria-label="Permalink to &quot;1.项目范围的配置&quot;">​</a></h2><p><code>babel@7.0</code> 开始，具有了<strong>根目录</strong>的概念。默认为当前工作目录。(<code>babel</code> 命令执行的目录)。</p><p>项目范围的配置，默认的搜索行为是，在当前执行转译命令的目录中直接寻找<code>babel.config.json</code>，找到的话，正常编译，否则不会编译。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>babel-config-demo/</span></span>
<span class="line"><span>.</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── node_modules</span></span>
<span class="line"><span>├── src</span></span>
<span class="line"><span>│   ├── main.js</span></span>
<span class="line"><span>│   └── package.json</span></span>
<span class="line"><span>├── babel.config.js</span></span>
<span class="line"><span>└── yarn.lock</span></span></code></pre></div><p>假设在项目 <code>babel-config-demo</code>中的目录结构如上。</p><p>那么当在 <code>babel-config-demo/</code> 目录下执行 <code>babel</code> 命令时，是可以正常转码的。而在 <code>babel-config-demo/src</code> 下无法转码。</p><p>另外也可以使用 <a href="https://www.babeljs.cn/docs/options#configfile" target="_blank" rel="noreferrer">configFile</a> 选项来指明具体的 <code>babel.config.json</code> 路径。需要注意的是，该选项仅允许利用<strong>编程方式</strong>使用。即创建 <code>js</code> 文件，手动引入 <code>@babel/core</code>, 调用 <code>api</code>。</p><p>此外，<code>babel.config.json</code> 也能对 <code>node_modules</code> 和 <code>symlinked packages</code> 内的文件进行转码。而 <code>.babelrc.json</code> 则不能。</p><p>从上面的论述中，我们简单总结下 <code>babel.config.json</code> 类文件的特点：</p><ul><li>必须存在于执行目录。执行命令的目录下，必须能找到 <code>babel.config.json</code>。</li><li>如果项目特殊，可以利用 <code>configFile</code> 选项，显式的指定 <code>babel.config.json</code> 的位置。</li><li><code>babel.config.json</code> 也能对 <code>node_modules</code> 和 <code>symlinked packages</code> 内的文件进行转码。</li></ul><h2 id="_2-相对文件的配置" tabindex="-1">2.相对文件的配置 <a class="header-anchor" href="#_2-相对文件的配置" aria-label="Permalink to &quot;2.相对文件的配置&quot;">​</a></h2><p>相对文件的配置，默认搜索行为是，根据执行命令先定位到转译的目标文件，基于目标文件的位置，逐次向上排查<code>.babelrc.json</code>。此搜索过程中，有两点注意：</p><ul><li>在此搜索过程中，一旦遇到 <code>package.json</code> 时，此搜索就会停止。</li><li>如果找到了 <code>.babelrc.json</code> ，则此 <code>.babelrc.json</code> 必须与执行命令在同一级目录。否则 <code>.babelrc.json</code> 会被忽略，文件不会转译。</li></ul><h3 id="示例一" tabindex="-1">示例一 <a class="header-anchor" href="#示例一" aria-label="Permalink to &quot;示例一&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>babelrc-demo/</span></span>
<span class="line"><span>.</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── node_modules</span></span>
<span class="line"><span>├── src</span></span>
<span class="line"><span>│   ├── main.js</span></span>
<span class="line"><span>│   └── package.json</span></span>
<span class="line"><span>├── .babelrc</span></span>
<span class="line"><span>└── yarn.lock</span></span></code></pre></div><p>在 <code>babelrc-demo/</code> 下执行 <code>yarn compiler</code> 命令时，会先定位到 <code>src/main.js</code> 。然后顺此文件向上查找 <code>.babelrc</code>。但由于 <code>src</code> 文件夹内有 <code>package.json</code>，所以查找会立刻停止，直接在 <code>src</code> 下寻找 <code>.babelrc</code>。可想而知，并不会正常执行。</p><h3 id="示例二" tabindex="-1">示例二 <a class="header-anchor" href="#示例二" aria-label="Permalink to &quot;示例二&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>babelrc-demo/</span></span>
<span class="line"><span>.</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── node_modules</span></span>
<span class="line"><span>├── src</span></span>
<span class="line"><span>|   └── .babelrc</span></span>
<span class="line"><span>│   ├── main.js</span></span>
<span class="line"><span>│   └── package.json</span></span>
<span class="line"><span>├── .babelrc</span></span>
<span class="line"><span>└── yarn.lock</span></span></code></pre></div><p>该例相比上例，在 <code>src</code> 下多了 <code>.babelrc</code>。</p><p>同样，在 <code>babelrc-demo/</code> 下执行 <code>yarn compiler</code> 命令时，会先定位到 <code>src/main.js</code> 。虽然此时在 <code>src</code> 下可以找到 <code>.babelrc</code>。但由于命令是在 <code>babelrc-demo/</code> 下，而 <code>.babelrc</code> 是在 <code>babelrc-demo/src/</code> 下，两者并不在同一目录，结果也是执行失败。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在大部分情况下，使用项目范围的配置与相对文件的配置，差异并不大。</p><p><code>babel</code> 之所以要将配置文件分为这两类，主要是为了方便开发者管理类似 <code>@babel</code> 这种 <code>mono packages</code> 项目。既能统一集中的管理通用的 <code>babel</code> 配置（项目范围的配置），又能根据各个 <code>package</code> 的实际情况做单独的配置（相对文件的配置）。当两种配置同时找到了的时候，相对文件的配置，将会与项目范围的配置进行合并，然后才应用到<strong>子package</strong>。</p>`,31)]))}const h=a(o,[["render",d]]);export{g as __pageData,h as default};
