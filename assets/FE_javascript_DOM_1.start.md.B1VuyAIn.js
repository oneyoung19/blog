import{_ as i,o as s,c as a,b0 as t}from"./chunks/framework.BnowZdcM.js";const k=JSON.parse('{"title":"基础","description":"","frontmatter":{"title":"基础"},"headers":[],"relativePath":"FE/javascript/DOM/1.start.md","filePath":"FE/javascript/DOM/1.start.md","lastUpdated":1770606126000}'),l={name:"FE/javascript/DOM/1.start.md"};function o(d,e,n,c,p,r){return s(),a("div",null,[...e[0]||(e[0]=[t(`<h2 id="_1-介绍" tabindex="-1">1.介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1.介绍&quot;">​</a></h2><p><code>DOM</code> 全意即为 <code>Document Object Model</code>，<strong>文档对象模型</strong>。</p><p>它将整个网页视作一份文档，文档当中包含许多节点，如<strong>文本节点</strong>、<strong>属性节点</strong>以及<strong>元素节点</strong>。</p><p>另外它提供了一系列用来操作更改这些节点的方法与属性。</p><h2 id="_2-方法" tabindex="-1">2.方法 <a class="header-anchor" href="#_2-方法" aria-label="Permalink to &quot;2.方法&quot;">​</a></h2><h3 id="_2-1-选择器" tabindex="-1">2-1.选择器 <a class="header-anchor" href="#_2-1-选择器" aria-label="Permalink to &quot;2-1.选择器&quot;">​</a></h3><ul><li><code>document.getElementById()</code> 根据 <code>id</code> 获取唯一元素。</li><li><code>document.getElementsByClassName()</code> 根据类名获取所有元素。</li><li><code>document.getElementsByTagName()</code> 根据标签名获取所有元素。</li><li><code>document.querySelector()</code> 根据 <code>id</code>、<code>className</code> 或者 <code>tagName</code> 获取唯一元素。</li><li><code>document.querySelectorAll()</code> 根据 <code>id</code>、<code>className</code> 或者 <code>tagName</code> 获取所有元素。</li></ul><h3 id="_2-2-节点操作" tabindex="-1">2-2.节点操作 <a class="header-anchor" href="#_2-2-节点操作" aria-label="Permalink to &quot;2-2.节点操作&quot;">​</a></h3><ul><li><p><code>document.createElement()</code> 创建元素节点。</p></li><li><p><code>document.createTextNode()</code> 创建文本节点。</p></li><li><p><code>document.createAttribute()</code> 创建属性节点。</p></li><li><p><code>appendChild()</code> 添加子节点。</p></li><li><p><code>removeChild()</code> 删除子节点。</p></li><li><p><code>replaceChild()</code> 替换子节点。</p></li><li><p><code>insertBefore()</code> 在节点前插入节点。</p></li></ul><h3 id="_2-3-属性操作" tabindex="-1">2-3.属性操作 <a class="header-anchor" href="#_2-3-属性操作" aria-label="Permalink to &quot;2-3.属性操作&quot;">​</a></h3><ul><li><code>getAttribute()</code> 获取属性值。</li><li><code>setAttribute()</code> 修改属性值。</li><li><code>hasAttribute()</code> 是否含有某一属性值。</li><li><code>removeAttribute</code> 移除属性。</li></ul><h2 id="_3-属性" tabindex="-1">3.属性 <a class="header-anchor" href="#_3-属性" aria-label="Permalink to &quot;3.属性&quot;">​</a></h2><p>说到 <code>DOM属性</code>，用的最广泛的应该是 <code>style</code> 属性。但是值得注意的，<strong>利用该属性只能得到行内属性，而不是元素的计算属性。</strong></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果不仅仅要获取元素的行内属性的话，可以使用 <code>window.getComputedStyle(element, pseudoElt)</code> 这个方法。</p><p>也可以使用 <code>offset</code> 系列的部分相关属性，后一章我们会详细说明。</p></div><p>简单介绍下：</p><p><code>window.getComputedStyle(element, pseudoElt)</code> 可以用来获取目标元素的计算样式。</p><p>也可以利用第二个参数 <code>pseudoElt</code> 来获取目标元素的伪元素（<code>before</code>、<code>afetr</code>）的计算样式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComputedStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取具体样式时，有两种方法。假设要获取 ‘背景颜色’.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ① 直接利用获取对象属性的方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.backgroundColor)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ② 利用 element.getPropertyValue(property)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPropertyValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background-color&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二种方式相对第一种方式，更友好的一点在于，不用在考虑JS中的驼峰命名，直接利用css的写法即可。</span></span></code></pre></div><p>此外，常用的属性还有：</p><ul><li><code>childNodes</code> 子节点，可能会包含文本节点、元素节点。</li><li><code>children</code> 子节点，只有元素节点。</li><li><code>previousSibling</code> 前一个兄弟节点。</li><li><code>nextSibling</code> 下一个兄弟节点。</li><li><code>parentNode</code> 父节点(可能是元素节点、文本节点或者文档片段节点)。</li><li><code>parentElement</code> 父元素节点。</li><li><code>firstChild</code> 第一个子节点。</li><li><code>lastChild</code> 最后一个子节点。</li></ul>`,20)])])}const g=i(l,[["render",o]]);export{k as __pageData,g as default};
