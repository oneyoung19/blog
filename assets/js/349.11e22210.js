(window.webpackJsonp=window.webpackJsonp||[]).push([[349],{808:function(t,e,v){"use strict";v.r(e);var _=v(40),n=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("混入")])]),t._v(" "),v("ol",[v("li",[t._v("混入对象")]),t._v(" "),v("li",[t._v("组件对象")])]),t._v(" "),v("p",[v("strong",[t._v("组件对象定义的优先级更高")]),t._v("。")]),t._v(" "),v("p",[t._v("譬如，"),v("code",[t._v("data")]),t._v(" 和 "),v("code",[t._v("methods")]),t._v(" 的相关定义，有重名的选项时，以组件对象为准。其余的混入对象选项，混入到组件对象中。")]),t._v(" "),v("p",[t._v("而对于 "),v("code",[t._v("created")]),t._v(" 等生命周期钩子函数，"),v("code",[t._v("vue")]),t._v(" 会以数组形式来存储，也就是说组件对象与混入对象的生命周期钩子函数都会执行，但组件对象的钩子函数在混入对象的钩子函数之后执行（这样，组件对象钩子逻辑能够覆盖混入对象钩子逻辑）。")]),t._v(" "),v("p",[t._v("TODO: Object.assign() 与 $.extend() 与 mixins")])])}),[],!1,null,null,null);e.default=n.exports}}]);