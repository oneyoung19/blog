(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{456:function(v,_,e){v.exports=e.p+"assets/img/module.history.drawio.835d3c9c.png"},572:function(v,_,e){"use strict";e.r(_);var o=e(40),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("p",[v._v("前端模块化的作用有两个：")]),v._v(" "),o("ol",[o("li",[v._v("不污染全局变量。")]),v._v(" "),o("li",[v._v("更好的组织和维护代码模块之间的关系。")])]),v._v(" "),o("p",[v._v("由于 "),o("code",[v._v("JavaScript")]),v._v(" 刚开始时，都是利用 "),o("code",[v._v("var")]),v._v(" 语法声明变量。")]),v._v(" "),o("p",[v._v("而 "),o("code",[v._v("var")]),v._v(" 声明的属性则有可能污染全局变量 "),o("code",[v._v("window")]),v._v("（函数作用域内的 "),o("code",[v._v("var")]),v._v(" 除外）。")]),v._v(" "),o("p",[v._v("由此，解决办法就是 "),o("code",[v._v("IIFE")]),v._v("（"),o("strong",[v._v("立即执行函数")]),v._v("）。")]),v._v(" "),o("p",[v._v("另外，在前端工程化概念未普及的时代，我们在开发时，通常是利用 "),o("code",[v._v("<script>")]),v._v(" 标签来引入 "),o("code",[v._v("JavaScript")]),v._v("。")]),v._v(" "),o("p",[v._v("但这样做有两个弊端：")]),v._v(" "),o("ol",[o("li",[v._v("需要严格控制 "),o("code",[v._v("script")]),v._v(" 的引用顺序。")]),v._v(" "),o("li",[o("code",[v._v("<script>")]),v._v(" 默认同步加载，不利于页面渲染。")])]),v._v(" "),o("p",[v._v("在这种情况下，衍生出了许多模块化标准：")]),v._v(" "),o("ul",[o("li",[o("code",[v._v("CommonJS")])]),v._v(" "),o("li",[o("code",[v._v("AMD")])]),v._v(" "),o("li",[o("code",[v._v("CMD")])]),v._v(" "),o("li",[o("code",[v._v("UMD")])]),v._v(" "),o("li",[o("code",[v._v("EsModule")])])]),v._v(" "),o("p",[v._v("在谈论具体的模块化规范之前，我们先梳理下"),o("strong",[v._v("模块化规范的历史")]),v._v("。")]),v._v(" "),o("p",[v._v("前端模块化的诞生，最早要追溯到 "),o("code",[v._v("Node")]),v._v(" 的出现。")]),v._v(" "),o("ol",[o("li",[o("p",[o("code",[v._v("Node")]),v._v(" 的模块化规范刚开始命名为 "),o("code",[v._v("ServerJS")]),v._v("，后来社区想要根据 "),o("code",[v._v("ServerJS")]),v._v(" 一统浏览器端和服务端的模块规范，更名为了 "),o("code",[v._v("CommonJS")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("但在这段进展中，有人觉得浏览器端有其本身的特性，应该据此设计新的模块规范 "),o("code",[v._v("AMD")]),v._v("，这一规范的标准产物是 "),o("code",[v._v("RequireJS")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("而后第三方库里，为了兼容 "),o("code",[v._v("CommonJS")]),v._v(" 和 "),o("code",[v._v("AMD")]),v._v(" 这两种规范，使用了 "),o("code",[v._v("UMD")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("还有一部分同学，觉得应该讲浏览器端的特性及 "),o("code",[v._v("CommonJS")]),v._v(" 规范相结合，从而有了 "),o("code",[v._v("CMD")]),v._v(" 规范，这一规范的标准产物是 "),o("code",[v._v("SeaJS")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("但 "),o("code",[v._v("CMD")]),v._v(" 的推广做的并不好，所以导致在实际应用和社区支持上远远比不上 "),o("code",[v._v("AMD")]),v._v(" 和 "),o("code",[v._v("CommonJS")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("而后，打包工具大行其是，前端工程化开始流行。即模块引用在开发时做好，构建过程中分析依赖，注入生产。标准产物是 "),o("code",[v._v("webpack")]),v._v(" 和 "),o("code",[v._v("browserify")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("如今，在 "),o("code",[v._v("Es6")]),v._v(" 中提供了新语法 "),o("code",[v._v("EsModule")]),v._v("，浏览器端也逐渐开始直接支持 "),o("code",[v._v("Module Script")]),v._v("。标准产物是 "),o("code",[v._v("Vite")]),v._v("。")])])]),v._v(" "),o("p",[o("img",{attrs:{src:e(456),alt:""}})]),v._v(" "),o("p",[v._v("参考文章：")]),v._v(" "),o("ul",[o("li",[o("p",[o("a",{attrs:{href:"https://github.com/seajs/seajs/issues/588",target:"_blank",rel:"noopener noreferrer"}},[v._v("前端模块化开发那点历史"),o("OutboundLink")],1)])]),v._v(" "),o("li",[o("p",[o("a",{attrs:{href:"http://huangxuan.me/js-module-7day/#/",target:"_blank",rel:"noopener noreferrer"}},[v._v("JavaScript 模块化七日谈"),o("OutboundLink")],1)])])])])}),[],!1,null,null,null);_.default=c.exports}}]);