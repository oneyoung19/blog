import{_ as i,c as a,o as e,b0 as t}from"./chunks/framework.D8aj9ziZ.js";const c=JSON.parse('{"title":"14.边界情况","description":"","frontmatter":{"title":"14.边界情况"},"headers":[],"relativePath":"frame/vue2/base/14.boundary.md","filePath":"frame/vue2/base/14.boundary.md","lastUpdated":1750216722000}'),n={name:"frame/vue2/base/14.boundary.md"};function p(l,s,h,d,o,k){return e(),a("div",null,s[0]||(s[0]=[t(`<h2 id="_14-1-访问元素-组件" tabindex="-1">14-1.访问元素 &amp; 组件 <a class="header-anchor" href="#_14-1-访问元素-组件" aria-label="Permalink to &quot;14-1.访问元素 &amp; 组件&quot;">​</a></h2><p>在某些情况下，可以使用这些手段。</p><p>访问根实例，<code>$root</code></p><p>访问父组件实例，<code>$parent</code></p><p>访问子组件实例, <code>$refs[childComponentName]</code></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。</p><p>这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 <code>$refs</code>。</p></div><p>在使用 <code>$parent</code> 时，只能父子组件通信，如果想要更深层级的通信，<code>Vue</code> 提供了<strong>依赖注入</strong>：</p><p>它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。</p><p>祖先组件内：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    getMap: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.getMap</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>任何后代组件内：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;getMap&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h2 id="_14-2-程序化的事件侦听器" tabindex="-1">14-2.程序化的事件侦听器 <a class="header-anchor" href="#_14-2-程序化的事件侦听器" aria-label="Permalink to &quot;14-2.程序化的事件侦听器&quot;">​</a></h2><ul><li><p><code>$on</code> 监听一个事件</p></li><li><p><code>$off</code> 停止监听一个事件</p></li><li><p><code>$once</code> 一次性监听一个事件</p></li></ul><p>在某些场景下，能够更好的管理维护自己的模块代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> picker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Pikaday</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    field: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$refs.input,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    format: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;YYYY-MM-DD&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hook:beforeDestroy&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    picker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">destroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>Vue</code> 的事件系统不同于浏览器的 <code>EventTarget API</code>。</p><p>尽管它们工作起来是相似的，但是 <code>$emit</code>、<code>$on</code>, 和 <code>$off</code> 并不是 <code>dispatchEvent</code>、<code>addEventListener</code> 和 <code>removeEventListener</code> 的别名。</p></div><h2 id="_14-3-循环引用" tabindex="-1">14-3.循环引用 <a class="header-anchor" href="#_14-3-循环引用" aria-label="Permalink to &quot;14-3.循环引用&quot;">​</a></h2><ol><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6" target="_blank" rel="noreferrer">递归组件</a></li></ol><p>组件是可以在它们自己的模板中调用自身的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;stack-overflow&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;</span></span></code></pre></div><p>类似上述的组件将会导致 <code>max stack size exceeded</code> 错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p><ol start="2"><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8" target="_blank" rel="noreferrer">组件之间的循环引用</a></li></ol><p>当通过 <code>Vue.component</code> 全局注册组件的时候，这个<strong>循环引用</strong>悖论会被自动解开。</p><p>但如果是通过 <code>webpack</code> 构建工具，就有可能遇见一个错误：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Failed to mount component: template or render function not defined.</span></span></code></pre></div><p>对应的解决办法是在生命周期钩子 <code>beforeCreate</code> 时才注册引用组件：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$options.components.TreeFolderContents </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./tree-folder-contents.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).default</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>也可以利用 <code>webpack</code> 的异步 <code>import</code>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  TreeFolderContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./tree-folder-contents.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_14-4-模板定义的替代品" tabindex="-1">14-4.模板定义的替代品 <a class="header-anchor" href="#_14-4-模板定义的替代品" aria-label="Permalink to &quot;14-4.模板定义的替代品&quot;">​</a></h2><p><code>Vue</code> 定义模板的推荐方式有二：</p><ol><li><code>template</code> 选项</li><li><code>.vue</code> 单文件中的 <code>&lt;template&gt;</code> 元素。</li></ol><p>除此以外，还有两种方式：</p><ol><li><p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF" target="_blank" rel="noreferrer">内联模板</a></p></li><li><p><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#X-Template" target="_blank" rel="noreferrer">X-Template</a></p></li></ol><h2 id="_14-5-控制更新" tabindex="-1">14-5.控制更新 <a class="header-anchor" href="#_14-5-控制更新" aria-label="Permalink to &quot;14-5.控制更新&quot;">​</a></h2><ol><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0" target="_blank" rel="noreferrer">强制更新</a></li></ol><p>利用 <code>$forceUpdate</code></p><ol start="2"><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E9%80%9A%E8%BF%87-v-once-%E5%88%9B%E5%BB%BA%E4%BD%8E%E5%BC%80%E9%94%80%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank" rel="noreferrer">通过 <code>v-once</code> 创建低开销的静态组件</a></li></ol><p>渲染普通的 <code>HTML</code> 元素在 <code>Vue</code> 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。</p><p>在这种情况下，你可以在根元素上添加 <code>v-once</code> <code>attribute</code> 以确保这些内容只计算一次然后缓存起来。</p>`,41)]))}const E=i(n,[["render",p]]);export{c as __pageData,E as default};
