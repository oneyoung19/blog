import{_ as i,o as a,c as t,aP as e}from"./chunks/framework.D1yHhm2y.js";const c=JSON.parse('{"title":"2FA","description":"","frontmatter":{"title":"2FA"},"headers":[],"relativePath":"BE/authentication/2fa/index.md","filePath":"BE/authentication/2fa/index.md","lastUpdated":1735962761000}'),n={name:"BE/authentication/2fa/index.md"};function l(p,s,o,h,k,d){return a(),t("div",null,s[0]||(s[0]=[e(`<p><code>2FA</code> 全称是 <code>Two-Factor Authentication</code>，即<strong>二要素验证</strong>。</p><p>它是一种用于提高账户安全性的身份验证方法，要求用户提供两种或更多种不同的身份验证要素，以确认其身份。</p><p>它增加了用户和组织的账户安全性，特别是在涉及敏感数据或重要服务的情况下。</p><p><code>2FA</code> 工作原理如下：</p><ol><li><p><strong>第一因素</strong>：通常是用户的常规登录凭据，例如用户名和密码。这是用户知道的信息。</p></li><li><p><strong>第二因素</strong>：通常是用户的物理设备、手机应用程序或生物识别数据（如指纹、面部识别）。这是用户拥有的东西或用户特定的信息。</p></li></ol><p>要成功登录，用户必须提供两种因素中的至少两种。这增加了账户的安全性，因为即使黑客获取了用户的密码（第一因素），他们仍然需要第二因素才能成功登录，而黑客通常不会拥有第二因素。</p><p>以下是一些常见的 <code>2FA</code> 方法：</p><ul><li><p><strong>手机短信验证码</strong>：用户在登录时会收到一条包含验证码的短信，他们需要输入这个验证码作为第二因素。</p></li><li><p><strong>身份验证应用程序</strong>：用户安装一个身份验证应用程序（如<code>Google Authenticator</code>、<code>Authy</code>、<code>Microsoft Authenticator</code>等），该应用程序生成每隔一段时间变化的一次性验证码，用户在登录时输入这个验证码作为第二因素。</p></li><li><p><strong>硬件令牌</strong>：这是一种物理令牌设备，用户必须在登录时插入或按下按钮，以生成一次性验证码。</p></li><li><p><strong>生物识别身份验证</strong>：这包括使用指纹识别、面部识别或虹膜扫描等生物识别数据作为第二因素。</p></li></ul><p><code>2FA</code> 是一种重要的安全措施，可防止大多数基于密码的攻击，如字典攻击、暴力破解和钓鱼。</p><p>许多在线服务和平台现在提供 <code>2FA</code> 选项，鼓励用户启用它以提高他们的安全性。</p><p>以 <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication" target="_blank" rel="noreferrer"><code>GitHub</code></a> 平台为例，设置 <code>2FA</code> 需要 <code>3</code> 步：</p><ol><li>在手机上安装<strong>APP验证程序</strong>，在手机商店中搜索安装即可，笔者在 <code>iphone</code> 上使用的是 <code>Google Authenticator</code>。</li></ol><p>然后扫码将 <code>Github</code> 平台与<strong>APP验证程序</strong>绑定。</p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/20230917180242.png" alt=""></p><ol start="2"><li><strong>下载恢复码并将其备份，方便日后使用</strong>。这是为了保证后续遗失的话，能通过恢复码在 <code>Github</code> 平台恢复功能。</li></ol><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/20230917164728.png" alt=""></p><ol start="3"><li><strong>绑定成功</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/20230917164833.png" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>截止到 <code>2023-09-17</code>, <code>Github</code> 平台支持 <code>2FA</code> 中的两种方式，<code>TOTP</code> <strong>时间型一次性密码</strong>和 <code>SMS</code> <strong>短信验证码</strong>。</p><p><code>TOTP</code> 的安全性和稳定性，都要高于 <code>SMS</code>。因此在实际操作中，推荐使用 <code>TOTP</code>。</p></div><h2 id="_1-totp" tabindex="-1">1.TOTP <a class="header-anchor" href="#_1-totp" aria-label="Permalink to &quot;1.TOTP&quot;">​</a></h2><p><code>TOTP</code> 的全称是 <code>Time-Based One-Time Password</code>，即<strong>时间型一次性密码</strong>。</p><p>由于 <code>TOTP</code> 基于时间，因此每隔一段时间（通常是 <code>30</code> 秒），生成的一次性密码都会发生变化，</p><p><code>TOTP</code> 的工作原理如下：</p><ol><li>用户在其设备上注册了一个 <code>TOTP</code> 令牌，通常是一个移动应用程序（如 <code>Google Authenticator</code> 或 <code>Authy</code>）中的虚拟令牌；</li><li>在注册过程中，服务器和用户的设备会共享一个密钥（密钥是一个秘密值）；</li><li>每次需要进行身份验证时，用户设备会生成一个基于当前时间的一次性密码；</li><li>用户将这个一次性密码输入到要登录的系统或服务中；</li><li>服务器也使用相同的密钥和当前时间来生成一个一次性密码；</li><li>服务器会比对用户输入的密码和自己生成的密码，如果匹配成功，用户就可以成功登录。</li></ol><p>以<a href="https://github.com/simontabor/2fa" target="_blank" rel="noreferrer">2FA</a>仓库来说明下代码逻辑：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tfa </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2fa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里的密钥key 即是和每个用户绑定的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tfa.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">generateKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>假设生成的 <code>key</code> 是 <code>22wgak4gqu122tq9i8yr1ypit5ppy87e</code>，那么 <code>30</code> 秒内，生成的 <code>code</code> 值应该是相等的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;22wgak4gqu122tq9i8yr1ypit5ppy87e&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tfa.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">generateCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, tc)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;totp&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, totp)</span></span></code></pre></div><h3 id="_1-1-优点" tabindex="-1">1-1.优点 <a class="header-anchor" href="#_1-1-优点" aria-label="Permalink to &quot;1-1.优点&quot;">​</a></h3><ol><li><strong>可以作为软件令牌使用</strong>；</li></ol><p><code>TOTP</code> 身份验证器可以嵌入专用硬件令牌中，也可以在软件中实现，通常作为移动应用程序，例如 <code>Google Authenticator</code>。</p><p>通过在软件（也称为软件令牌）中实施它，可以避免与硬件制造、分销、库存和维护相关的成本。</p><p><em><strong>能够在某种程度上，替代 <code>ukey</code> 等硬件</strong></em>。</p><ol start="2"><li><strong>无需互联网连接</strong>；</li></ol><p>这可能是 <code>TOTP</code> 的最大优势之一。</p><p>生成和接受 <code>TOTP</code> 代码的设备可以完全离线。</p><p>只要两个设备共享相同的密钥并同步，它们就可以单独生成 <code>TOTP</code> 代码并相互比较。</p><ol start="3"><li><strong>跨应用程序和渠道易于使用</strong>。</li></ol><p>可以使用 <code>TOTP</code> 访问各种类型的应用程序和渠道。</p><p>通常，每个应用程序和 <code>TOTP</code> 身份验证器之间都会有一个单独的 <code>TOTP</code> 代码。</p><p>假设使用 <code>TOTP</code> 登录 <code>10</code> 个不同的系统。那么仍然可以使用单个 <code>TOTP</code> 身份验证器，但 <code>TOTP</code> 身份验证器将生成 <code>10</code> 个不同的代码，每个应用程序一个。</p><p>譬如 <code>Google Authenticator</code> 可以同时绑定 <code>Github</code> 和 <code>NPM</code> 的 <code>2FA</code>。</p><h3 id="_1-2-缺点" tabindex="-1">1-2.缺点 <a class="header-anchor" href="#_1-2-缺点" aria-label="Permalink to &quot;1-2.缺点&quot;">​</a></h3><ol><li><strong>可能被网络钓鱼和窃取</strong>；</li></ol><p><code>TOTP</code> 缺乏上下文。您打开身份验证器应用程序，获得一个代码，然后将其放入需要它的系统中。</p><p>实时网络钓鱼攻击中，攻击者冒充某个服务网站并请求 <code>TOTP</code> 代码，攻击者可以获取该代码，然后立即使用它代表受害者登录该服务。</p><ol start="2"><li><strong>使用共享密钥</strong>；</li></ol><p>使用共享密钥从来都不是一个很好的安全实践。</p><p>这意味着服务提供商持有所有客户的所有 <code>TOTP</code> 生成器的密钥，如果这些密钥被盗，攻击者可以为用户生成代码。</p><ol start="3"><li><strong>设备相关</strong>。</li></ol><p><code>TOTP</code> 生成器绑定到用户的设备（例如移动设备或硬件令牌）。</p><p>如果该设备被盗、丢失或损坏，服务提供商和 <code>TOTP</code> 生成器之间的关联就会丢失，并且服务提供商需要为用户重新颁发 <code>TOTP</code> 验证器。</p><p>此时，服务提供商不能依赖 <code>TOTP</code> 生成器来验证用户，并且需要在重新发布生成器之前找到其他方法来验证用户。</p><h2 id="_2-hotp" tabindex="-1">2.HOTP <a class="header-anchor" href="#_2-hotp" aria-label="Permalink to &quot;2.HOTP&quot;">​</a></h2><p><code>HOTP</code> 的全称是 <code>HMAC-Based One-Time Password</code>，即<strong>事件型一次性密码</strong>。</p><p>该方式与 <code>TOTP</code> 基本类似，<strong>唯一的区别在于时间和事件的不同</strong>。</p><p><code>HOTP</code> 的工作原理如下：</p><ol><li>用户在其设备上注册一个 <code>HOTP</code> 令牌，通常是一个移动应用程序中的虚拟令牌，或者是硬件令牌。</li><li>在注册过程中，服务器和用户的设备会共享一个密钥（密钥是一个秘密值）。</li><li>每次需要进行身份验证时，用户设备会生成一个基于一个<strong>计数器</strong>和<strong>共享密钥</strong>的<strong>一次性密码</strong>。</li><li>用户将这个一次性密码输入到要登录的系统或服务中。</li><li>服务器也使用相同的密钥和其自己的计数器值来生成一个一次性密码。</li><li>服务器会比对用户输入的密码和自己生成的密码，如果匹配成功，用户就可以成功登录。</li></ol><p>从上面的流程可知，唯一的要点是，<strong>在某事件触发时，生成一个唯一的计数器</strong>。</p><p>因此事实上，我们依然<strong>可以利用时间戳来实现这个计数器效果</strong>，毕竟时间戳是永远唯一的。时间逝去永不在。</p><p>在<a href="https://github.com/simontabor/2fa" target="_blank" rel="noreferrer">2FA</a>中，也是一致的实现方式：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tfa </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2fa&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里的密钥key 即是和每个用户绑定的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tfa.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">generateKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>假设生成的 <code>key</code> 是 <code>22wgak4gqu122tq9i8yr1ypit5ppy87e</code>，那么生成一个计数器：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;22wgak4gqu122tq9i8yr1ypit5ppy87e&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hotp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tfa.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">generateCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, tc)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hotp&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hotp)</span></span></code></pre></div><h2 id="友情链接" tabindex="-1">友情链接 <a class="header-anchor" href="#友情链接" aria-label="Permalink to &quot;友情链接&quot;">​</a></h2><ul><li><a href="https://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" target="_blank" rel="noreferrer">双因素认证（2FA）教程——阮一峰</a></li><li><a href="https://transmitsecurity.com/blog/totp-the-good-the-bad-and-the-ugly" target="_blank" rel="noreferrer">TOTP与HOTP</a></li></ul>`,66)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
