import{_ as t,c as o,o as r,b0 as s}from"./chunks/framework.Ctc7-3V1.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"BE/node/nestjs/TODO.md","filePath":"BE/node/nestjs/TODO.md","lastUpdated":1748249253000}'),l={name:"BE/node/nestjs/TODO.md"};function c(a,e,n,d,i,p){return r(),o("div",null,e[0]||(e[0]=[s('<ol><li><p>degit</p></li><li><p><a href="https://docs.nestjs.com/first-steps#platform" target="_blank" rel="noreferrer">express &amp; fastify</a></p></li><li><p>快速生成 <code>controller</code>:</p><ul><li><code>nest g resource [name]</code></li><li><code>nest g controller [name]</code></li><li><code>nest g service [name]</code></li><li><code>nest g module [name]</code></li></ul></li><li><p><code>Injectable</code> 与 <code>Inject</code> 的使用场景</p></li><li><p>自定义 <code>Providers</code> 以及 <code>@Optional</code></p></li><li><p><code>nestjs</code> 的生命周期及<a href="https://docs.nestjs.com/fundamentals/lifecycle-events" target="_blank" rel="noreferrer">生命周期事件</a> Incoming Request ↓ [Middleware (Express)] （基于 Express 层，适合处理日志、请求体解析等通用逻辑） ↓ [Nest Lifecycle] ├─&gt; Global Guards ← 权限/认证控制（可依赖注入） ├─&gt; Route Guards ↓ ├─&gt; Global Pipes ← 参数验证、转换 ├─&gt; Route Pipes ↓ ├─&gt; Global Interceptors ← 方法前：日志、缓存、格式包装等 ├─&gt; Route Interceptors ↓ ├─&gt; Controller Handler ← 执行业务处理逻辑（Service 等） ↓ ├─&gt; Route Interceptors ← 方法后：结果包装、异常处理 ├─&gt; Global Interceptors ↓ [If any error occurs at any step above] ↓ Exception Filters (Route → Global) ← 捕获异常，统一格式响应</p></li><li><p><a href="https://docs.nestjs.com/controllers#state-sharing" target="_blank" rel="noreferrer">State sharing</a> &quot;对于来自其他编程语言的开发者来说，你可能会惊讶地发现，在 Nest 中，几乎所有内容都是在传入请求之间共享的。这包括数据库连接池、具有全局状态的单例服务等等。重要的是要理解，Node.js 不使用请求/响应多线程无状态模型，该模型中每个请求都由单独的线程处理。因此，在 Nest 中使用单例实例对我们的应用程序来说是完全安全的 。&quot; TODO: 这个要结合 <code>learn-nodejs</code> 重新梳理下</p><p>1.微服务或者多机部署的 状态共享 2.同一时间内的多请求 单线程与多线程 的处理异同，如何保证多线程的请求安全？（JAVA 分布式事务？） 3.日志链路追踪</p></li><li><p>控制反转 <code>IOC</code> 以及依赖注入 <code>DI</code></p></li><li><p><code>nestjs</code> 中的<a href="https://docs.nestjs.com/recipes/async-local-storage" target="_blank" rel="noreferrer">Async Local Storage</a></p></li></ol>',1)]))}const g=t(l,[["render",c]]);export{f as __pageData,g as default};
