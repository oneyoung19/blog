import{_ as s,c as i,o as t,b0 as e}from"./chunks/framework.CEggy_nf.js";const k=JSON.parse('{"title":"12.模块化","description":"","frontmatter":{"title":"12.模块化"},"headers":[],"relativePath":"BE/java/docs/12.module.md","filePath":"BE/java/docs/12.module.md","lastUpdated":1744462650000}'),l={name:"BE/java/docs/12.module.md"};function d(h,a,n,o,p,r){return t(),i("div",null,a[0]||(a[0]=[e(`<p><code>Java</code> 的模块化是指在 <code>Java 9</code> 引入的 <strong>模块系统（Java Platform Module System, JPMS）</strong>，这是 <code>Java</code> 平台自发布以来最重大的结构性变革之一。它的核心目标是让 <code>Java</code> 应用可以更好地进行组织、封装和依赖管理。</p><h3 id="一、模块化的动机" tabindex="-1">一、模块化的动机 <a class="header-anchor" href="#一、模块化的动机" aria-label="Permalink to &quot;一、模块化的动机&quot;">​</a></h3><p>在 <code>Java 9</code> 之前，<code>Java</code> 程序使用的是包（<code>package</code>）来组织类，但包之间的依赖和访问控制是很松散的。常见问题有：</p><ul><li>无法限制包之间的访问（即使是内部实现也可能被外部代码访问）。</li><li>难以追踪依赖（比如 <code>JAR</code> 冲突、类路径地狱）。</li><li>标准库越来越庞大，难以裁剪、维护。</li></ul><p><code>Java</code> 模块化系统旨在解决这些问题。</p><h3 id="二、模块基本概念" tabindex="-1">二、模块基本概念 <a class="header-anchor" href="#二、模块基本概念" aria-label="Permalink to &quot;二、模块基本概念&quot;">​</a></h3><h4 id="_1-模块-module" tabindex="-1">1. 模块（Module） <a class="header-anchor" href="#_1-模块-module" aria-label="Permalink to &quot;1. 模块（Module）&quot;">​</a></h4><p>模块是一组相关的 <strong>包</strong> 的集合，打包成一个单元。每个模块都有一个 <code>module-info.java</code> 文件来声明：</p><ul><li>当前模块的名称</li><li>该模块依赖的其他模块</li><li>该模块对外暴露的包</li></ul><h4 id="_2-module-info-java-文件示例" tabindex="-1">2. <code>module-info.java</code> 文件示例 <a class="header-anchor" href="#_2-module-info-java-文件示例" aria-label="Permalink to &quot;2. \`module-info.java\` 文件示例&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> com</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.example.myapp {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    requires</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.sql; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 依赖于 java.sql 模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.myapp.api; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 暴露 API 包</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="三、关键关键字" tabindex="-1">三、关键关键字 <a class="header-anchor" href="#三、关键关键字" aria-label="Permalink to &quot;三、关键关键字&quot;">​</a></h3><table tabindex="0"><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>module</code></td><td>声明模块</td></tr><tr><td><code>requires</code></td><td>指定依赖的模块</td></tr><tr><td><code>exports</code></td><td>将模块中的某个包暴露出去，供其他模块使用</td></tr><tr><td><code>opens</code></td><td>允许反射访问指定包（通常用于框架如 Spring）</td></tr><tr><td><code>provides ... with ...</code></td><td>模块服务提供者机制（SPI）</td></tr><tr><td><code>uses</code></td><td>模块服务使用者机制（SPI）</td></tr></tbody></table><h3 id="四、模块路径-vs-类路径" tabindex="-1">四、模块路径 vs 类路径 <a class="header-anchor" href="#四、模块路径-vs-类路径" aria-label="Permalink to &quot;四、模块路径 vs 类路径&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类路径（Classpath）</th><th>模块路径（Module Path）</th></tr></thead><tbody><tr><td>没有真正的模块概念</td><td>有明确模块划分与依赖关系</td></tr><tr><td>所有类共享命名空间</td><td>每个模块独立命名空间</td></tr><tr><td>容易产生冲突</td><td>冲突更容易被编译器发现</td></tr><tr><td>无访问控制</td><td>模块之间默认不能访问私有包</td></tr></tbody></table><h3 id="五、标准模块化-jdk" tabindex="-1">五、标准模块化 JDK <a class="header-anchor" href="#五、标准模块化-jdk" aria-label="Permalink to &quot;五、标准模块化 JDK&quot;">​</a></h3><p>JDK 本身也被模块化成了很多模块，例如：</p><ul><li><code>java.base</code>：最基本的模块，所有模块都隐式依赖它（包含 java.lang, java.util 等）</li><li><code>java.sql</code>：JDBC 模块</li><li><code>java.xml</code>：XML 处理模块</li></ul><p>可以通过命令查看 JDK 的模块：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --list-modules</span></span></code></pre></div><h3 id="六、模块化对开发的影响" tabindex="-1">六、模块化对开发的影响 <a class="header-anchor" href="#六、模块化对开发的影响" aria-label="Permalink to &quot;六、模块化对开发的影响&quot;">​</a></h3><h4 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h4><ul><li>更清晰的依赖管理</li><li>更强的封装（内部包不可访问）</li><li>更小的运行体积（可以裁剪模块）</li><li>更好的支持大型项目结构</li></ul><h4 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h4><ul><li>学习成本增加</li><li>兼容旧的第三方库可能有问题（不支持模块化的库）</li><li>Spring 等反射框架需要 <code>opens</code> 支持</li></ul><h3 id="七、常用命令" tabindex="-1">七、常用命令 <a class="header-anchor" href="#七、常用命令" aria-label="Permalink to &quot;七、常用命令&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 编译模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">javac</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --module-source-path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> src</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;*.java&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --module-path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> com.example.myapp/com.example.myapp.Main</span></span></code></pre></div><hr>`,28)]))}const u=s(l,[["render",d]]);export{k as __pageData,u as default};
