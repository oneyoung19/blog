import{_ as t,o as a,c as s,aP as o}from"./chunks/framework.D1yHhm2y.js";const k=JSON.parse('{"title":"编码方式","description":"","frontmatter":{"title":"编码方式"},"headers":[],"relativePath":"cs/string/2.utf.md","filePath":"cs/string/2.utf.md","lastUpdated":1736069910000}'),i={name:"cs/string/2.utf.md"};function n(r,e,c,p,d,l){return a(),s("div",null,e[0]||(e[0]=[o(`<p>在上一节，我们介绍了<strong>字符集</strong>。</p><p>我们能够认识到<strong>每一个字符都会对应一个码值</strong>。</p><p>这一节，我们来了解下<strong>编码方式</strong>。</p><p><strong>同一个码值在不同的编码方式下，它的字节长度和表示方式是不同的。</strong></p><h2 id="_1-ucs-2" tabindex="-1">1.UCS-2 <a class="header-anchor" href="#_1-ucs-2" aria-label="Permalink to &quot;1.UCS-2&quot;">​</a></h2><h2 id="_2-utf-16" tabindex="-1">2.UTF-16 <a class="header-anchor" href="#_2-utf-16" aria-label="Permalink to &quot;2.UTF-16&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;😂&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre></div><p>这其实是由于 <strong><code>JavaScript</code> 的字符串长度是按照 <code>utf-16</code> 代码单元来读取的</strong>。</p><p>这部分内容可见 <code>ECMAScript</code> 语言标准：<a href="https://262.ecma-international.org/5.1/#sec-8.4" target="_blank" rel="noreferrer">ECMAScript® Language Specification</a>。</p><blockquote><p>字符串类型是由 0 位或 16 位以上无符号整数值(元素)组成的所有有限有序序列的集合。</p></blockquote><blockquote><p>字符串类型通常用于表示运行中的ECMAScript 程序中的文本数据，在这种情况下，字符串中的每个元素都被视为码元值(参见第6条)。</p></blockquote><blockquote><p>这些位置用非负整数作索引。第一个元素(如果有)位于位置 0，下一个元素(如果有)位于位置 1，以此类推。字符串的长度是元素的数量(即，16位值)。空字符串的长度为零，因此不包含任何元素。</p></blockquote><blockquote><p>当字符串包含实际的文本数据时，每个元素都被认为是一个单独的 UTF-16 码元。</p></blockquote><blockquote><p>无论这是否是字符串的实际存储格式，字符串中的字符都是通过其初始码元元素位置进行编号的，就像使用 UTF-16 表示一样。所有字符串上的操作(除非另有说明)都将它们视为无差异 16 位无符号整数的序列，它们不能确保得到的字符串是标准格式的，也不能确保得到对语言敏感的结果。</p></blockquote><h2 id="_3-utf-32" tabindex="-1">3.UTF-32 <a class="header-anchor" href="#_3-utf-32" aria-label="Permalink to &quot;3.UTF-32&quot;">​</a></h2><h2 id="_4-utf-8" tabindex="-1">4.UTF-8 <a class="header-anchor" href="#_4-utf-8" aria-label="Permalink to &quot;4.UTF-8&quot;">​</a></h2><p><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noreferrer">UTF-8-维基百科</a></p><p><code>UTF-8</code>（<code>8-bit Unicode Transformation Format</code>）是一种针对 <code>Unicode</code> 的<strong>可变长度字符编码</strong>，也是一种<strong>前缀码</strong>。</p><p>它可以用<strong>一至四个字节</strong>对 <code>Unicode</code> 字符集中的所有有效编码点进行编码，属于 <code>Unicode</code> 标准的一部分。</p><p><code>UTF-8</code> 就是为了解决向后兼容 <code>ASCII</code> 码而设计，<code>Unicode</code> 中前 <code>128</code> 个字符，使用与 <code>ASCII</code> 码相同的二进制值的单个字节进行编码，而且字面与<code>ASCII</code> 码的字面一一对应，这使得原来处理 <code>ASCII</code> 字符的软件无须或只须做少部分修改，即可继续使用。</p>`,20)]))}const g=t(i,[["render",n]]);export{k as __pageData,g as default};
