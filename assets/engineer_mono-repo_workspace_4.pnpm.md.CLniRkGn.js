import{_ as a,o as e,c as i,aP as p}from"./chunks/framework.DeCM12M7.js";const d=JSON.parse('{"title":"PNPM","description":"","frontmatter":{"title":"PNPM"},"headers":[],"relativePath":"engineer/mono-repo/workspace/4.pnpm.md","filePath":"engineer/mono-repo/workspace/4.pnpm.md","lastUpdated":1736513424000}'),n={name:"engineer/mono-repo/workspace/4.pnpm.md"};function l(t,s,o,r,c,h){return e(),i("div",null,s[0]||(s[0]=[p(`<p><code>pnpm</code> 相对于 <code>npm</code> 解决了两个方面的问题：</p><ol><li><strong>幻影依赖</strong>。依赖扁平化，导致项目能够直接引入可能没在 <code>package.json</code> 中声明的依赖。</li><li><strong>分身依赖</strong>。扁平化但不完全，导致子依赖中会存在其他依赖的特定版本。如果这种情况在同一个项目中众多且重复，也有很大的性能损耗。</li></ol><p>其实 <code>pnpm</code> 的 <code>workspaces</code> 结合 <code>lerna</code> 使用的优势也在于解决了以上两点。</p><h2 id="_1-使用单个workspace" tabindex="-1">1.使用单个workspace <a class="header-anchor" href="#_1-使用单个workspace" aria-label="Permalink to &quot;1.使用单个workspace&quot;">​</a></h2><p>使用 <code>--filter</code> 参数，可访问指定的单个 <code>workspace</code>：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">comman</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --filter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">workspac</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>譬如：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vue</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --filter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span></span></code></pre></div><h2 id="_2-使用workspaces" tabindex="-1">2.使用workspaces <a class="header-anchor" href="#_2-使用workspaces" aria-label="Permalink to &quot;2.使用workspaces&quot;">​</a></h2><p><code>pnpm</code> 貌似没有提供相关的访问整个 <code>workspaces</code> 的指令方式。</p><h2 id="_3-pnpm-workspace-yaml" tabindex="-1">3.pnpm-workspace.yaml <a class="header-anchor" href="#_3-pnpm-workspace-yaml" aria-label="Permalink to &quot;3.pnpm-workspace.yaml&quot;">​</a></h2><p>不同于 <code>npm</code> 与 <code>yarn</code> 在 <code>package.json</code> 中定义 <code>workspaces</code>。</p><p><code>pnpm</code> 需要单独创建 <code>pnpm-workspace.yaml</code> 文件。</p><p>首先在 <code>pnpm-workspace.yaml</code> 中定义 <code>packages</code>:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">packages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;packages/*&#39;</span></span></code></pre></div><h2 id="_4-npmrc" tabindex="-1">4.<code>.npmrc</code> <a class="header-anchor" href="#_4-npmrc" aria-label="Permalink to &quot;4.\`.npmrc\`&quot;">​</a></h2><p>在 <code>.npmrc</code> 中可写入以下配置（<strong>可选</strong>）：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将本地包连接到node_modules</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">link-workspace-packages=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 优先使用工作目录的package，只有save-workspace-protocal=false时有效</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">prefer-workspace-packages=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 共享lock文件，有利于模块解析</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shared-workspace-lockfile=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 用来控制依赖在package.json中的版本范围</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">save-workspace-protocol=true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 递归执行是否作用在根工作区</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">include-workspace-root=false</span></span></code></pre></div><h2 id="_5-参考文档" tabindex="-1">5.参考文档 <a class="header-anchor" href="#_5-参考文档" aria-label="Permalink to &quot;5.参考文档&quot;">​</a></h2><ul><li><a href="https://lerna.js.org/docs/recipes/using-pnpm-with-lerna" target="_blank" rel="noreferrer">结合 <code>pnpm</code> 使用 <code>lerna</code></a></li><li><a href="https://zhuanlan.zhihu.com/p/419399115" target="_blank" rel="noreferrer">为什么推荐使用 <code>pnpm</code></a></li><li><a href="https://auu.zone/post/workspace" target="_blank" rel="noreferrer">monorepo-不同包管理器workspace的使用方法</a></li></ul>`,20)]))}const g=a(n,[["render",l]]);export{d as __pageData,g as default};
