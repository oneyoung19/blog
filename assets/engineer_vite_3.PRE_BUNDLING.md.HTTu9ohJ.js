import{_ as o,c as t,o as c,b0 as d}from"./chunks/framework.CEggy_nf.js";const m=JSON.parse('{"title":"3.依赖预构建","description":"","frontmatter":{"title":"3.依赖预构建"},"headers":[],"relativePath":"engineer/vite/3.PRE_BUNDLING.md","filePath":"engineer/vite/3.PRE_BUNDLING.md","lastUpdated":1744903323000}'),r={name:"engineer/vite/3.PRE_BUNDLING.md"};function s(i,e,a,l,n,p){return c(),t("div",null,e[0]||(e[0]=[d('<p>目的:</p><ol><li><p><strong>CommonJS 和 UMD 兼容性</strong>。将 <code>CommonJS</code> 和 <code>UMD</code> 规范转化为 <code>ES</code> 模块规范，以便浏览器支持。</p></li><li><p><strong>性能</strong>。将 <code>lodash</code> 这样的具有大量内置模块的包，转化为单个模块。</p></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>笔者实际测试了下，发现无论是开发环境，还是生产环境，<code>vite</code> 对于 <code>import { debounce } from &#39;lodash&#39;</code> 这样的语法，其实是将整个 <code>lodash</code> 包打成了一个依赖。并没有做 <code>tree shaking</code>。</p></div><ol start="3"><li><strong>转化第三方包</strong>。譬如浏览器对于 <code>import { debounce } from &#39;lodash&#39;</code> 是无法解析的。报错：<code>Uncaught TypeError: Failed to resolve module specifier &quot;lodash&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;</code>。</li></ol>',4)]))}const u=o(r,[["render",s]]);export{m as __pageData,u as default};
