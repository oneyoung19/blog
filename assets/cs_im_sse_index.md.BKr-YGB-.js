import{_ as o,c as r,o as t,b0 as a}from"./chunks/framework.D8aj9ziZ.js";const h=JSON.parse('{"title":"SSE","description":"","frontmatter":{"title":"SSE"},"headers":[],"relativePath":"cs/im/sse/index.md","filePath":"cs/im/sse/index.md","lastUpdated":1749894304000}'),n={name:"cs/im/sse/index.md"};function s(c,e,i,l,d,p){return t(),r("div",null,e[0]||(e[0]=[a('<p><code>SSE</code> 全称为 <code>Server-sent Events</code>。即<strong>服务端推送事件</strong>。</p><p>在实际业务中，我们可以利用 <code>SSE</code> 向客户端不间断的推送实时信息。</p><h2 id="_1-优点" tabindex="-1">1.优点 <a class="header-anchor" href="#_1-优点" aria-label="Permalink to &quot;1.优点&quot;">​</a></h2><p><code>SSE</code> 具有以下特点：</p><ol><li><strong>单向通信</strong>。只能由服务端向客户端推动消息。而 <code>websocket</code> 属于全双工通信；</li><li><strong>依赖HTTP协议</strong>。而 <code>websocket</code> 依赖的是 <code>ws</code> 或者 <code>wss</code> 协议；</li><li><strong>传输数据只能是文本数据</strong>。而 <code>websocket</code> 可以传输二进制和文本数据；</li><li><strong>持久化连接</strong>。与 <code>websocket</code> 类似，<code>Connection</code> 的值为 <code>keep-alive</code>；（<strong>且 <code>SSE</code> 的连接，客户端会不断发送请求，除非显示调用 <code>source.close()</code> 实例方法关闭连接</strong>。）</li><li><strong>特有的重连机制</strong>。在网络不好或者连接出错时，<code>SSE</code> 会自动 <code>retry</code> 连接。</li></ol><h2 id="_2-缺点" tabindex="-1">2.缺点 <a class="header-anchor" href="#_2-缺点" aria-label="Permalink to &quot;2.缺点&quot;">​</a></h2><p>由于 <code>SSE</code> 依赖 <code>HTTP</code> 协议的<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="noreferrer">keep-alive</a>长连接，</p><p>而 <code>keep-alive</code> 长连接在浏览器客户端的并发量是有上限的。一般上限为 <code>6</code>。</p><p>因此，在业务开发中，如果同时存在超上限的连接数，有可能会出现网络阻塞。</p><h2 id="_3-兼容性" tabindex="-1">3.兼容性 <a class="header-anchor" href="#_3-兼容性" aria-label="Permalink to &quot;3.兼容性&quot;">​</a></h2><p><a href="https://caniuse.com/eventsource" target="_blank" rel="noreferrer">caniuse.com</a></p><p><img src="https://raw.githubusercontent.com/oneyoung19/vuepress-blog-img/Not-Count-Contribution/img/20240509163849.png" alt="" loading="lazy"></p><h2 id="_3-参考文档" tabindex="-1">3.参考文档 <a class="header-anchor" href="#_3-参考文档" aria-label="Permalink to &quot;3.参考文档&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" target="_blank" rel="noreferrer">MDN</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noreferrer">Server-Sent Events 教程——阮一峰</a></li><li><a href="https://zh.javascript.info/server-sent-events" target="_blank" rel="noreferrer">现代教程之Server Sent Events</a></li><li><a href="https://segmentfault.com/a/1190000019697463" target="_blank" rel="noreferrer">你可能不知道的浏览器实时通信方案</a></li></ul>',14)]))}const g=o(n,[["render",s]]);export{h as __pageData,g as default};
