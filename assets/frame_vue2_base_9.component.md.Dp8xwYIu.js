import{_ as p,C as t,c as l,o as h,b0 as a,j as n,a as i,G as k}from"./chunks/framework.CEggy_nf.js";const u=JSON.parse('{"title":"9.组件","description":"","frontmatter":{"title":"9.组件"},"headers":[],"relativePath":"frame/vue2/base/9.component.md","filePath":"frame/vue2/base/9.component.md","lastUpdated":1743843633000}'),o={name:"frame/vue2/base/9.component.md"};function d(c,s,r,E,g,y){const e=t("component");return h(),l("div",null,[s[4]||(s[4]=a(`<p>为了保证组件的<strong>复用性</strong>，组件中的 <code>data</code> 必须是一个函数。</p><p>组件内部定义需要是<strong>单个根元素</strong>。</p><h2 id="_9-1-全局注册" tabindex="-1">9-1.全局注册 <a class="header-anchor" href="#_9-1-全局注册" aria-label="Permalink to &quot;9-1.全局注册&quot;">​</a></h2><p>全局注册，适用于注册<strong>全局组件</strong>。</p><p>注册一次，全局可用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ComponentA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>全局注册的行为必须在根 <code>Vue</code> 实例 (通过 <code>new Vue</code>) 创建之前发生。</p></div><p><strong>自动化全局注册</strong></p><p>在现实的<strong>工程化</strong>开发中，人工手动全局注册一个个的组件，显得非常麻烦，代码也会非常冗余。</p><p>假设有以下目录：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── components</span></span>
<span class="line"><span>│   ├── BaseButton.vue</span></span>
<span class="line"><span>│   ├── index.js</span></span>
<span class="line"><span>│   └── table</span></span>
<span class="line"><span>│       └── BaseTable.vue</span></span></code></pre></div><p>以 <code>webpack</code> 中的 <code>require.context</code> 为例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> upperFirst </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;lodash/upperFirst&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camelCase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;lodash/camelCase&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取该文件的执行上下文 返回值是一个函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> require.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../components&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">vue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可利用属性keys获取该上下文的符合条件的文件名数组集合</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">filePath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 根据文件路径获取大写组件名 譬如 ./table/BaseTable.vue 的结果是 BaseTable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> componentName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> upperFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">camelCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spilit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 根据文件路径获取组件相关信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> componentInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 全局注册 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    componentName,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果这个组件选项是通过 \`export default\` 导出的，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 那么就会优先使用 \`.default\`，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 否则回退到使用模块的根。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    componentInfo.default </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> componentInfo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="_9-2-局部注册" tabindex="-1">9-2.局部注册 <a class="header-anchor" href="#_9-2-局部注册" aria-label="Permalink to &quot;9-2.局部注册&quot;">​</a></h2><p>局部注册相对于全局注册的一个优势，在使用形如 <code>webpack</code> 的构建系统时，不会打包冗余代码，有利于 <code>tree-shaking</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ComponentA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;path/to/ComponentA&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComponentB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ComponentA</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_9-3-prop" tabindex="-1">9-3.prop <a class="header-anchor" href="#_9-3-prop" aria-label="Permalink to &quot;9-3.prop&quot;">​</a></h2><ol><li>单向数据流</li></ol><p>如果改变了 <code>prop</code>，会报错：</p><p><code>Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&#39;s value.</code></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>注意，这里的改变 <code>prop</code> 指的是<strong>改变了 <code>prop</code> 的指向</strong>。</p><p>如果 <code>prop</code> 是对象 <code>object</code>，那么改变其属性时不会触发报错（<strong>并没有改变其地址指向</strong>），直接改变其指向才会报错。</p><p>但在子组件中改变对象类型的 <code>prop</code> 属性将会影响到父组件的状态。</p><p>因为基本数据类型的映射是<strong>值</strong>，复杂数据类型的映射是<strong>引用</strong>。</p></div><ol start="2"><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E9%9D%9E-Prop-%E7%9A%84-Attribute" target="_blank" rel="noreferrer">非 Prop 的 Attribute</a></li></ol><p>非 <code>prop</code> 的 <code>attribute</code> 默认会作用于<strong>子组件的根元素</strong>上，并且会覆盖该根元素上设置的属性（<code>class</code>、<code>style</code> 较为特殊，这俩会重新组合属性）。</p><ol start="3"><li>禁用 <code>Attribute</code> 继承</li></ol><p>设置 <code>inheritAttrs: false</code>，子组件的根元素将不会继承父组件内设置的 <code>attribute</code>。</p><p>注意 <code>inheritAttrs: false</code> 选项不会影响 <code>style</code> 和 <code>class</code> 的绑定。</p><p>可利用 <code>inheritAttrs: false</code> 结合 <code>v-bind=&quot;$attrs&quot;</code>，指定子组件内的目标元素接收父组件内设置的 <code>attribute</code>。（<strong>同样，这里 <code>style</code> 和 <code>class</code> 的绑定也不会受影响</strong>）</p><h2 id="_9-4-自定义事件" tabindex="-1">9-4.自定义事件 <a class="header-anchor" href="#_9-4-自定义事件" aria-label="Permalink to &quot;9-4.自定义事件&quot;">​</a></h2><ol><li><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model" target="_blank" rel="noreferrer">自定义 <code>v-model</code></a></li></ol><p><code>v-model</code> 默认等于 <code>v-bind:value</code> 及 <code>v-on:input=&quot;value = $event.target.value&quot;</code>。</p><p>所以 <code>v-model</code> 会改变 <code>value</code> 属性的值。</p><p>在单选框 <code>radio</code> 或者复选框 <code>checkbox</code> 上，<code>v-model</code> 如果绑定的是基本类型的值，则会将 <code>value</code> 修改为 <code>true</code> 或 <code>false</code>。</p><p>在某些表单下（譬如 <code>checkbox</code>）, <code>value</code> 属性是可以结合 <code>name</code> 属性通过 <code>form</code> 表单提交到服务端的，但 <code>value</code> 不能是 <code>true</code> 或 <code>false</code>，即使在 <code>DOM</code> 中布尔值被认作字符串。</p><p>通过上述论述，可知在某些场景下，表单元素需要 <code>value</code> 属性进行其他操作时，此时我们不能粗暴的直接使用 <code>v-model</code> 进行绑定，<code>Vue</code> 对此提供了 <code>modle</code> 属性供我们自定义 <code>v-model</code> 绑定。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;base-checkbox&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  model: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prop: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;checked&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    event: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;change&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    checked: Boolean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;input</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      type=&quot;checkbox&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      v-bind:checked=&quot;checked&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  \`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="2"><li><code>$listeners</code></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;base-input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  inheritAttrs: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;label&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    inputListeners</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // \`Object.assign\` 将所有的对象合并为一个新对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({},</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 我们从父级添加所有的监听器</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$listeners,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 然后我们添加自定义监听器，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 或覆写一些监听器的行为</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 这里确保组件配合 \`v-model\` 的工作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            vm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.target.value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;label&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      {{ label }}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &lt;input</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        v-bind=&quot;$attrs&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        v-bind:value=&quot;value&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        v-on=&quot;inputListeners&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &lt;/label&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  \`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="_9-5-插槽" tabindex="-1">9-5.插槽 <a class="header-anchor" href="#_9-5-插槽" aria-label="Permalink to &quot;9-5.插槽&quot;">​</a></h2><p><a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noreferrer">插槽</a></p><p><strong>在子组件中</strong>：</p><p>使用 <code>&lt;slot&gt;&lt;/slot&gt;</code> 预留默认插槽。</p><p>使用 <code>&lt;slot name=&quot;name&quot;&gt;&lt;/slot&gt;</code> 预留具名插槽。</p><p>使用 <code>&lt;slot name=&quot;name&quot; :prop=&quot;prop&quot;&gt;&lt;/slot&gt;</code> 来预留具名作用域插槽。</p><p><strong>在父组件中</strong></p><ol><li>新语法</li></ol><p>自 <code>2.6.0</code> 起的新版本语法，提供了 <code>v-slot</code>，可缩写为 <code>#</code>。</p><p><strong>推荐在所有情况下都用在 <code>&lt;template&gt;</code> 标签上。</strong></p><p>默认插槽，<code>v-slot</code> 或 <code>v-slot:default</code></p><p>具名插槽，<code>v-slot:[name]</code></p><p>作用域插槽，<code>v-slot:[name]=&quot;slotProps&quot;</code></p><ol start="2"><li>旧语法</li></ol><p>旧语法，是 <code>slot</code> 与 <code>slot-scope</code>。</p><p>默认插槽，直接填充 或 <code>slot=&quot;default&quot;</code>。</p><p>具名插槽，<code>slot=&quot;name&quot;</code></p><p>作用域插槽，<code>slot=&quot;name&quot; slot-scope=&quot;slotProps&quot;</code></p><ol start="3"><li>编译作用域</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></div><h2 id="_9-6-动态组件-异步组件" tabindex="-1">9-6.动态组件&amp;异步组件 <a class="header-anchor" href="#_9-6-动态组件-异步组件" aria-label="Permalink to &quot;9-6.动态组件&amp;异步组件&quot;">​</a></h2><ol><li>动态组件</li></ol><p>动态组件可利用 <code>is</code> 属性进行切换。</p><p>组件会重新渲染。</p>`,61)),n("p",null,[s[0]||(s[0]=i("① 利用 ")),k(e),s[1]||(s[1]=i(" 元素的 ")),s[2]||(s[2]=n("code",null,"is",-1)),s[3]||(s[3]=i(" 属性"))]),s[5]||(s[5]=a(`<p>② <code>is</code> 属性应该用 <code>v-bind</code> 修饰（可以简写为 : ）</p><p>③ <code>is</code> 属性应该传入注册的组件名</p><p>如果想要动态组件保留状态，可以使用 <code>&lt;keep-alive&gt;</code> 来缓存。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>条件渲染 <code>v-if</code> 与动态组件 <code>:is</code> 的区别：</p><ol><li><p>条件渲染</p><ul><li>工作方式：根据 <code>v-if</code> 和 <code>v-else-if</code> 的条件，<code>Vue</code> 会决定渲染 <code>TextComponent</code>、<code>ImageComponent</code>、或 <code>JsonComponent</code>。</li><li>优缺点：每个组件的渲染条件都是独立的。如果有多个条件判断（比如更多的组件类型），代码会变得较冗长。</li><li>性能：条件渲染会根据条件判断只创建一个满足条件的组件，但每次重新渲染时，<code>Vue</code> 可能会销毁和重建组件。</li></ul></li><li><p>动态组件</p><ul><li>工作方式：通过 <code>:is</code> 绑定动态指定的组件名称，<code>Vue</code> 自动渲染与 item 变量相对应的组件，比如 <code>TextComponent</code>、<code>ImageComponent</code> 或 <code>JsonComponent</code>。</li><li>优缺点：代码更加简洁，尤其是当有很多种可能的组件类型时，无需为每种类型写条件判断。</li><li>性能：动态组件会复用现有组件实例，减少频繁的销毁和重建。动态组件的显示和隐藏通常不会销毁组件实例（除非设置 <code>key</code> 强制重新渲染）。</li></ul></li></ol></div><ol start="2"><li>异步组件</li></ol><p>异步组件根据 <code>resolve</code> 和 <code>reject</code> 的执行情况，决定组件的渲染。</p><p>支持以下两种用法：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&#39;my-component&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./my-async-component&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vue@2.3.0+，vue-router@2.4.0+</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&#39;my-component&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 需要加载的组件 (应该是一个 \`Promise\` 对象)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		component: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./MyComponent.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 异步组件加载时使用的组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		loading: LoadingComponent,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 加载失败时使用的组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		error: ErrorComponent,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		delay: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 如果提供了超时时间且组件加载也超时了，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 则使用加载失败时使用的组件。默认值是：\`Infinity\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		timeout: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>Webpack</code> 提供了<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noreferrer">code-splitting</a>来将 <code>import()</code> 语法的相关 <code>chunks</code> 自动抽离为 <code>Async chunks</code>。</p><p>另外，<code>Webpack</code> 还会提供 <code>Prefetch</code> 和 <code>Preload</code> 来优化异步组件的加载。</p><p>异步组件整体执行逻辑如下：</p><ol><li><p>在打包时，<code>Webpack</code> 会根据 <code>import()</code> 语法，<strong>将相关 <code>chunks</code> 抽离为 <code>Async chunks</code></strong>。</p></li><li><p>当 <code>Vue</code> 的异步路由被触发时，<code>webpack_require</code> 会被调用，<strong>利用 <code>JSONP</code> 来获取 <code>Async chunks</code></strong>。</p></li><li><p>当 <code>Async chunks</code> 加载成功后，会调用 <code>resolve</code> 方法，<code>Vue</code> 会根据组件名称进行渲染。</p></li><li><p>如果加载失败，会调用 <code>reject</code> 方法，<code>Vue</code> 会根据组件名称进行渲染。</p></li></ol>`,12))])}const m=p(o,[["render",d]]);export{u as __pageData,m as default};
